{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PiKVM Handbook","text":""},{"location":"#pikvm-handbook","title":"PiKVM Handbook","text":"<p>Welcome to the PiKVM Handbook - a complete documentation of Open and cheap DIY IP-KVM based on Raspberry Pi. Here you will find comprehensive information about all aspects of the operation of PiKVM, get answers to your most difficult questions and be able to solve the problems that have arisen.</p>"},{"location":"#where-to-start","title":"Where to start?","text":"<ul> <li>Learn about the basics of working with PiKVM.</li> <li>If you are a happy PiKVM V4/V3 owner then we have some special guides for you:<ul> <li>PiKVM V4 Mini &amp; Plus</li> <li>PiKVM V3 HAT / Pre-Assembled</li> </ul> </li> <li>Explore the features of PiKVM using the site's table of contents.</li> <li>If you encounter a problem, take a look at the FAQ, but if nothing helped, contact our Discord chat - experienced users and the PiKVM team will definitely help you.</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Official website: https://pikvm.org</li> <li>Our GitHub: https://github.com/pikvm</li> <li>Discord server: </li> <li>Subreddit: </li> </ul>"},{"location":"3d_printing/","title":"Cases for 3D printing","text":""},{"location":"3d_printing/#cases-for-3d-printing","title":"Cases for 3D printing","text":""},{"location":"3d_printing/#pikvm-v3-hat-cases","title":"PiKVM V3 HAT cases","text":"<ul> <li>v3.3 model (Kickstarter, Store)</li> <li>Unofficial but great v3.3 case mod for Noctua fan</li> <li>v3.2 model (Pre-release)</li> </ul>"},{"location":"3d_printing/#diy-cases","title":"DIY cases","text":"Model Notes https://www.thingiverse.com/thing:4799094 Case for the USB-C/PWR Splitter without Barrel jack https://www.thingiverse.com/thing:4931970 Case for the USB-C/PWR Splitter without Barrel jack https://www.thingiverse.com/thing:4862304 Case for PiKVM (LCD + ATX) https://www.thingiverse.com/thing:4868258 R4C3R - Low Profile PCIe bracket for PiKVM based on Raspberry Pi Zero + Lusya + ATX controls https://www.thingiverse.com/thing:4866005 R4C3R - Full Profile PCIe bracket for PiKVM based on Raspberry Pi Zero + Lusya + ATX controls https://www.thingiverse.com/thing:4832248 Case for the USB-C/PWR Splitter without Barrel jack and HDMI-CSI bridge https://www.thingiverse.com/thing:4916230 A very compact case without internal power splitter https://www.thingiverse.com/thing:4915627 ZeroW + CSI case https://www.thingiverse.com/thing:4950281 PiKVM RETRO Case for CSI-2 C779 Bridge w/ OLED Display Screen https://www.thingiverse.com/thing:4950280 USB Power Blocker Case https://www.thingiverse.com/thing:4642116 Conix's PI-KVM case for v2"},{"location":"_usb_limits/","title":"usb limits","text":"USB limitations <p>TL;DR: By default, you can add only one additional device to choose from, such as USB Ethernet, or USB Serial, or an extra Mass Storage Drive.</p> <p>There is a hardware limit on the number of devices that can be emulated at the same time. Each USB device uses so-called endpoints to communicate with the host. Depending on the type, the device consumes a different number of endpoints, while their total number is limited by the capabilities of the chip, for Raspberry Pi it is 8.</p> <p>It is quite difficult to calculate the number of endpoints used, but in the case of PiKVM, you can focus on the following numbers:</p> Device Endpoints Keyboard, mouse 1 for each Mass Storage Drive 2 for each USB Ethernet, USB Serial 3 for each <p>V2 and V3 emulates one mouse by default, V4 emulates two mouses. Thus, V2 and V3 use 4 endpoints, and V4 uses 5 by default.</p> <p>Creating an axtra Mass Storage Drive consumes additional endpoints, as well as USB Serial and USB Ethernet, so only a limited number of devices can be selected for the final configuration, for example, one USB Ethernet.</p> <p>If you need something more non-standard, you can disable the regular Mass Storage Drive and the additional mouse (on V4) to free up some extra endpoints.</p> <p>The <code>kvmd-otg</code> service is responsible for setting up USB emulation. If the endpoint limit is exceeded, the service will not be able to start and no emulated USB device will work.</p> <p>In the log it looks something like this:</p> <pre><code># journalctl -u kvmd-otg\n...\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- ===== Preparing complete =====\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- Enabling the gadget ...\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- WRITE --- /sys/kernel/config/usb_gadget/kvmd/UDC\nkvmd-otg[382]: OSError: [Errno 524] Unknown error 524\nkvmd-otg[382]: During handling of the above exception, another exception occurred:\nkvmd-otg[382]: Traceback (most recent call last):\nkvmd-otg[382]:   File \"/usr/bin/kvmd-otg\", line 9, in &lt;module&gt;\nkvmd-otg[382]:     main()\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 348, in main\nkvmd-otg[382]:     options.cmd(config)\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 278, in _cmd_start\nkvmd-otg[382]:     _write(join(gadget_path, \"UDC\"), udc)\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 83, in _write\nkvmd-otg[382]:     with open(path, \"w\") as file:\nkvmd-otg[382]: OSError: [Errno 524] Unknown error 524\nsystemd[1]: kvmd-otg.service: Main process exited, code=exited, status=1/FAILURE\nsystemd[1]: kvmd-otg.service: Failed with result 'exit-code'.\nsystemd[1]: Failed to start PiKVM - OTG setup.\n</code></pre> <p>In this case, you need to disable some of the previously enabled devices and restart PiKVM.</p>"},{"location":"api/","title":"HTTP API reference","text":""},{"location":"api/#api","title":"API","text":"<p>This document describes the PiKVM API. Since the system consists of microservices, here is a common API with a common entry point provided by Nginx. The examples above use <code>curl</code> and <code>websocat</code> with the <code>-k</code> option to disable SSL certificate verification, since the self-signed certificateis used in the default installation.</p>"},{"location":"api/#authentication","title":"Authentication","text":"<p>All APIs are restricted to authentication. To make requests, you either need to auth each request individually, or get a token and pass it as a cookie with each request.</p> <p>With enabled 2FA, you will need to add the one-time code to the password without spaces. That is, if the password is <code>foobar</code> and the code is <code>123456</code>, then you need to use <code>foobar123456</code> as the password.</p> <p>The code can be generated using any TOTP library, for example in Python:</p> <pre><code>import requests\nimport pyotp\n\nuser = \"admin\"\npasswd = \"admin\"\nsecret = \"3OBBOGSJRYRBZH35PGXURM4CMWTH3WSU\"  # Can be found in /etc/kvmd/totp.secret\n\nprint(requests.get(\n    url=\"https://pikvm/api/info\",\n    verify=False,  # For self-signed SSL certificate\n    headers={\n        \"X-KVMD-User\": user,\n        \"X-KVMD-Passwd\": passwd + pyotp.TOTP(secret).now(),\n    },\n).text)\n</code></pre> <p>Since in the borderline case of the 2FA code lifetime, the code may be invalid, it makes sense to either handle error 403 by repeating the request in seconds.</p> <p>A more correct way is to combine this method and check the remaining lifetime and postpone the request if there is a second or so left. You can find out how much time is left in this way:</p> <pre><code>totp = pyotp.TOTP(secret)\nnow = int(time.time())\nremaining = now - (now % totp.interval)\n</code></pre>"},{"location":"api/#single-request-auth","title":"Single request auth","text":"<p>There are two options here:</p> <ul> <li> <p>Using X-headers. Just pass <code>X-KVMD-User</code> and <code>X-KVMD-Passwd</code> with the request:</p> <pre><code>$ curl -k -H X-KVMD-User:admin -H X-KVMD-Passwd:admin https://&lt;pikvm-ip&gt;/api/auth/check\n</code></pre> </li> <li> <p>Using HTTP Basic Auth. Please note: contrary to the standard, this method DOES NOT use the <code>WWW-Authenticate</code> header. HTTP Basic Auth in this implementation is intended only for compatibility with other systems, such as Prometheus.</p> <pre><code>$ curl -k -u admin:admin https://&lt;pikvm-ip&gt;/api/auth/check\n</code></pre> </li> </ul>"},{"location":"api/#session-based-cookie-auth","title":"Session-based cookie auth","text":"<ol> <li> <p>Get the access token for the user using <code>POST /api/auth/login</code>:</p> <pre><code>$ curl -k -v -X POST --data user=admin --data passwd=admin https://pikvm/api/auth/login\n...\n&lt; Set-Cookie: auth_token=796cb83b11de4fcb749bc1bad14a91fb06dede84672b2f847fef1e988e6900de; Path=/\n...\n</code></pre> <p>On success the cookie <code>auth_token</code> will be received with <code>200 OK</code>. On invalid user or password you will get <code>403 Forbidden</code>.</p> </li> <li> <p>The handle <code>GET /api/auth/check</code> can be used for check the auth status. Return of <code>200 OK</code> will signal that user is authenticated. If the token or any of the single-request auth methods are missing, <code>401 Unauthorized</code> will be returned. In case of incorrect credentials or token, <code>403 Forbidden</code> will be returned.</p> </li> <li> <p>The handle <code>POST /api/auth/logout</code> can be used to invalidate session token. The response codes will be similar to the previous handle.</p> </li> </ol>"},{"location":"api/#websocket-events","title":"WebSocket events","text":"<p>Most of the data during the user's work with pikvm is transmitted over WebSocket. This includes mouse events, keyboard input, change the state of the various subsystems (such as ATX and Mass Storage Drive). Each event type will be described in the corresponding paragraph for its component. When connecting via WebSocket, the client receives current states as separate events. Then, as the states change, it will receive new events.</p> <p>In a normal situation, opening a socket session triggers the video streamer to start. The streamer works as long as there is at least one client connected via WebSocket. After the last connection is closed and the client timeout expires, the streamer will also be terminated.</p> <p>It is possible create a session that will not start the streamer and will not be counted when counting clients to stop the streamer. To do this, use the URL parameter <code>stream=0</code>:</p> <pre><code>$ websocat -k wss://&lt;pikvm-ip&gt;/api/ws?stream=0 -H X-KVMD-User:admin -H X-KVMD-Passwd:admin\n</code></pre> Output with initial events <pre><code>{\"event_type\": \"gpio_model_state\", \"event\": {\"scheme\": {\"inputs\": {\"led1\": {\"hw\": {\"driver\": \"__gpio__\", \"pin\": 19}}, \"led2\": {\"hw\": {\"driver\": \"__gpio__\", \"pin\": 16}}}, \"outputs\": {\"button1\": {\"switch\": false, \"pulse\": {\"delay\": 0.1, \"min_delay\": 0.1, \"max_delay\": 0.1}, \"hw\": {\"driver\": \"__gpio__\", \"pin\": 26}}, \"button2\": {\"switch\": false, \"pulse\": {\"delay\": 0.1, \"min_delay\": 0.1, \"max_delay\": 0.1}, \"hw\": {\"driver\": \"__gpio__\", \"pin\": 20}}, \"relay1\": {\"switch\": true, \"pulse\": {\"delay\": 0.1, \"min_delay\": 0.1, \"max_delay\": 0.1}, \"hw\": {\"driver\": \"relay\", \"pin\": 0}}, \"relay2\": {\"switch\": true, \"pulse\": {\"delay\": 2.0, \"min_delay\": 0.1, \"max_delay\": 5.0}, \"hw\": {\"driver\": \"relay\", \"pin\": 1}}}}, \"view\": {\"header\": {\"title\": \"Switches\"}, \"table\": [[{\"type\": \"label\", \"text\": \"Generic GPIO leds\"}], null, [{\"type\": \"label\", \"text\": \"Test 1:\"}, {\"type\": \"input\", \"channel\": \"led1\", \"color\": \"green\"}, {\"type\": \"output\", \"channel\": \"button1\", \"text\": \"Click\"}], [{\"type\": \"label\", \"text\": \"Test 2:\"}, {\"type\": \"input\", \"channel\": \"led2\", \"color\": \"green\"}, {\"type\": \"output\", \"channel\": \"button2\", \"text\": \"Click\"}], null, [{\"type\": \"label\", \"text\": \"HID Relays /dev/hidraw0\"}], null, [{\"type\": \"label\", \"text\": \"Relay #1:\"}, {\"type\": \"output\", \"channel\": \"relay1\", \"text\": \"Boop 0.1\"}], [{\"type\": \"label\", \"text\": \"Relay #2:\"}, {\"type\": \"output\", \"channel\": \"relay2\", \"text\": \"Boop 2.0\"}]]}}}\n{\"event_type\": \"info_extras_state\", \"event\": {\"vnc\": {\"name\": \"VNC\", \"description\": \"Show VNC information\", \"icon\": \"share/svg/vnc.svg\", \"path\": \"vnc\", \"keyboard_cap\": false, \"daemon\": \"kvmd-vnc\", \"port\": 5900, \"place\": 20, \"enabled\": true}, \"ipmi\": {\"name\": \"IPMI\", \"description\": \"Show IPMI information\", \"icon\": \"share/svg/ipmi.svg\", \"path\": \"ipmi\", \"keyboard_cap\": false, \"daemon\": \"kvmd-ipmi\", \"port\": 623, \"place\": 21, \"enabled\": true}}}\n{\"event_type\": \"info_hw_state\", \"event\": {\"platform\": {\"type\": \"rpi\", \"base\": \"Virtual Raspberry Pi\"}, \"health\": {\"temp\": {\"cpu\": 36.511, \"gpu\": 35.0}, \"throttling\": {\"raw_flags\": 0, \"parsed_flags\": {\"undervoltage\": {\"now\": false, \"past\": false}, \"freq_capped\": {\"now\": false, \"past\": false}, \"throttled\": {\"now\": false, \"past\": false}}}}}}\n{\"event_type\": \"info_meta_state\", \"event\": {\"server\": {\"host\": \"localhost.localdomain\"}, \"kvm\": {}}}\n{\"event_type\": \"info_system_state\", \"event\": {\"kvmd\": {\"version\": \"1.102\"}, \"streamer\": {\"app\": \"ustreamer\", \"version\": \"1.25\", \"features\": {\"WITH_OMX\": false, \"WITH_GPIO\": false, \"WITH_PTHREAD_NP\": true, \"WITH_SETPROCTITLE\": true, \"HAS_PDEATHSIG\": true}}, \"kernel\": {\"system\": \"Linux\", \"release\": \"5.8.10-arch1-1\", \"version\": \"#1 SMP PREEMPT Thu, 17 Sep 2020 18:01:06 +0000\", \"machine\": \"x86_64\"}}}\n{\"event_type\": \"wol_state\", \"event\": {\"enabled\": false, \"target\": {\"ip\": \"255.255.255.255\", \"port\": 9, \"mac\": \"\"}}}\n{\"event_type\": \"gpio_state\", \"event\": {\"inputs\": {\"led1\": {\"online\": true, \"state\": false}, \"led2\": {\"online\": true, \"state\": false}}, \"outputs\": {\"button1\": {\"online\": true, \"state\": false, \"busy\": false}, \"button2\": {\"online\": true, \"state\": false, \"busy\": false}, \"relay1\": {\"online\": false, \"state\": false, \"busy\": false}, \"relay2\": {\"online\": false, \"state\": false, \"busy\": false}}}}\n{\"event_type\": \"hid_state\", \"event\": {\"online\": true, \"keyboard\": {\"online\": true, \"leds\": {\"caps\": false, \"scroll\": false, \"num\": false}}, \"mouse\": {\"online\": true}}}\n{\"event_type\": \"atx_state\", \"event\": {\"enabled\": true, \"busy\": false, \"leds\": {\"power\": false, \"hdd\": false}}}\n{\"event_type\": \"msd_state\", \"event\": {\"enabled\": true, \"online\": true, \"busy\": false, \"storage\": {\"size\": 234950152192, \"free\": 23514271744, \"images\": {}, \"uploading\": false}, \"drive\": {\"image\": null, \"connected\": false, \"cdrom\": true}, \"features\": {\"multi\": true, \"cdrom\": true}}}\n{\"event_type\": \"streamer_state\", \"event\": {\"limits\": {\"max_fps\": 40}, \"params\": {\"desired_fps\": 30, \"quality\": 80}, \"snapshot\": {\"saved\": null}, \"streamer\": null, \"features\": {\"quality\": true, \"resolution\": false}}}\n{\"event_type\": \"loop\", \"event\": {}}\n</code></pre> <p>After connecting the client receives a bundle of states of all KVMD subsystems. After the batch is completed, it sends a <code>loop</code> event, which means that the websocket has entered event loop mode. Now it will send new states and respond to client's requests.</p> <p>Another type of event is <code>ping</code>, which can be sent by the client: <code>{\"event_type\": \"ping\", \"event\": {}}</code>. If the server is running, it will respond with pong: <code>{\"event_type\": \"pong\", \"event\": {}}</code>.</p> Sending key events using Python <p>For keypresses, set <code>event_type</code> to <code>key</code> and fill in the <code>event</code> structure with <code>key</code> and <code>state</code>, where <code>key</code> is the key from mapping and <code>state</code> is boolean that determines if the key is pressed or released: </p> <pre><code># python, install websocket-client\nimport websocket\nuri = \"wss://10.0.0.7/api/ws?stream=0\"\nheaders = {\"X-KVMD-User\": \"admin\", \"X-KVMD-Passwd\": \"admin\"}\nws = websocket.WebSocket(sslopt={\"cert_reqs\": ssl.CERT_NONE})\nws.connect(uri, header=headers)\nws.send('{\"event_type\": \"key\", \"event\": {\"key\": \"Enter\", \"state\": true}}')\ntime.sleep(0.05)\nws.send('{\"event_type\": \"key\", \"event\": {\"key\": \"Enter\", \"state\": false}}')\nws.close()\n</code></pre>"},{"location":"api/#system-functions","title":"System functions","text":""},{"location":"api/#get-system-info","title":"Get system info","text":"<p>The <code>GET /api/info</code> handle returns the general information about the PiKVM device.</p> <p>Parameters:</p> <ul> <li><code>fields=...</code> (optional) - Only specified categories will be returned, for example <code>fields=system,hw</code>. By default all categories will be displayed.</li> </ul> <pre><code>$ curl -k -u admin:admin https://&lt;pikvm-ip&gt;/api/info\n</code></pre> Click to expand <pre><code>{\n\"ok\": true,\n\"result\": {\n\"extras\": { // Installed applications; null on internal error\n\"ipmi\": {\n\"daemon\": \"kvmd-ipmi\",\n\"description\": \"Show IPMI information\",\n\"enabled\": true,\n\"icon\": \"share/svg/ipmi.svg\",\n\"keyboard_cap\": false,\n\"name\": \"IPMI\",\n\"path\": \"ipmi\",\n\"place\": 21,\n\"port\": 623\n},\n\"vnc\": {\n\"daemon\": \"kvmd-vnc\",\n\"description\": \"Show VNC information\",\n\"enabled\": true,\n\"icon\": \"share/svg/vnc.svg\",\n\"keyboard_cap\": false,\n\"name\": \"VNC\",\n\"path\": \"vnc\",\n\"place\": 20,\n\"port\": 5900\n}\n},\n\"hw\": { // Hardware info\n\"health\": {\n\"temp\": {\n\"cpu\": 36.511, // /sys/class/thermal/thermal_zone0/temp / 1000; null on error\n\"gpu\": 35.0    // vcgencmd measure_temp; null on error\n},\n\"throttling\": { // vcgencmd get_throttled; null on error\n\"parsed_flags\": {\n\"freq_capped\": {\n\"now\": false,\n\"past\": false\n},\n\"throttled\": {\n\"now\": false,\n\"past\": false\n},\n\"undervoltage\": {\n\"now\": false,\n\"past\": false\n}\n},\n\"raw_flags\": 0\n}\n},\n\"platform\": {\n\"base\": \"Raspberry Pi 4 Model B Rev 1.1\", // /proc/device-tree/model; null on error\n\"serial\": \"0000000000000000\", // /proc/device-tree/serial-number; null on error\n\"type\": \"rpi\"\n}\n},\n\"meta\": {  // /etc/kvmd/meta.yaml; null on error\n\"kvm\": {},\n\"server\": {\n\"host\": \"localhost.localdomain\"\n}\n},\n\"system\": {\n\"kernel\": {\n\"machine\": \"x86_64\",\n\"release\": \"5.8.14-arch1-1\",\n\"system\": \"Linux\",\n\"version\": \"#1 SMP PREEMPT Wed, 07 Oct 2020 23:59:46 +0000\"\n},\n\"kvmd\": {\n\"version\": \"2.1\"\n},\n\"streamer\": {\n\"app\": \"ustreamer\",\n\"features\": { // {} on error\n\"HAS_PDEATHSIG\": true,\n\"WITH_GPIO\": false,\n\"WITH_OMX\": false,\n\"WITH_PTHREAD_NP\": true,\n\"WITH_SETPROCTITLE\": true\n},\n\"version\": \"2.1\" // \"\" on error\n}\n}\n}\n}\n</code></pre> <p>Each category is represented by its own event in the websocket (<code>info_hw_state</code>, <code>info_system_state</code>, etc). The event content has the same format as the category content in API.</p>"},{"location":"api/#get-system-log","title":"Get system log","text":"<p>The <code>GET /api/log</code> handle displays logs from all KVMD services as plain text.</p> <p>Parameters:</p> <ul> <li><code>follow=1</code> (optional) - Turns the request into long-polling mode and follow log messages in real time.</li> <li><code>seek=N</code> (optional) - Runs the log for the specified time in seconds, for example <code>seek=3600</code> will show the log for the last hour.</li> </ul> <pre><code>$ curl -k -u admin:admin https://&lt;pikvm-ip&gt;/api/log\n</code></pre>"},{"location":"api/#atx-power-management","title":"ATX power management","text":""},{"location":"api/#get-atx-state","title":"Get ATX state","text":"<p>The <code>GET /api/atx</code> handle shows the current ATX state.</p> <pre><code>$ curl -k -u admin:admin https://&lt;pikvm-ip&gt;/api/atx\n</code></pre> Click to expand <pre><code>{\n\"ok\": true,\n\"result\": {\n\"busy\": false, // True if ATX is busy performing an operation and does not accept commands\n\"enabled\": true,\n\"leds\": {\n\"hdd\": false,\n\"power\": false\n}\n}\n}\n</code></pre>"},{"location":"api/#set-atx-power","title":"Set ATX power","text":"<p>The <code>POST /api/atx/power</code> handle changes ATX power state to desired.</p> <p>Parameters:</p> <ul> <li><code>action=...</code> - Describes desired state:<ul> <li><code>on</code> - Turn on (do nothing in case PSU is already on).</li> <li><code>off</code> - Turn off (aka soft-off), emulates click on the power button.</li> <li><code>off_hard</code> - Perform long press on the power button (5+ seconds).</li> <li><code>reset_hard</code> - Emulates pressing reset button (hardware hot reset).</li> </ul> </li> <li><code>wait=1</code> (optional) - Says if call should return immediately or just after finishing operation.</li> </ul> <pre><code>$ curl -X POST -k -u admin:admin https://&lt;pikvm-ip&gt;/api/atx/power?action=on\n</code></pre>"},{"location":"api/#click-atx-button","title":"Click ATX button","text":"<p>The <code>POST /api/atx/click</code> handle sends the ATX button press event.</p> <p>Parameters:</p> <ul> <li><code>button=...</code> - Specifies the desired PC case button:<ul> <li><code>power</code> - Short click on the power button.</li> <li><code>power_long</code> - Long press on the power button (5+ seconds).</li> <li><code>reset</code> - Short click on the reset button.</li> </ul> </li> <li><code>wait=1</code> (Optional) - Says if call should return immediately or just after finishing operation.</li> </ul> <pre><code>$ curl -X POST -k -u admin:admin https://&lt;pikvm-ip&gt;/api/atx/click?button=power\n</code></pre>"},{"location":"api/#mass-storage-drive","title":"Mass Storage Drive","text":""},{"location":"api/#get-msd-state","title":"Get MSD state","text":"<p>The <code>GET /api/msd</code> handle shows the current MSD state.</p> <pre><code>$ curl -k -u admin:admin https://&lt;pikvm-ip&gt;/api/msd\n</code></pre>"},{"location":"api/#upload-msd-image","title":"Upload MSD image","text":"<p>The <code>POST /api/msd/write</code> uploads an image to MSD.</p> <p>Parameters:</p> <ul> <li><code>image=...</code> - Specifies the name of the image.</li> <li>Binary data should be passed to the POST body.</li> </ul> <pre><code>$ # create a test image\n$ dd if=/dev/zero of=test.iso bs=1M count=1\n\n$ # upload it to pikvm\n$ curl -v -X POST --data-binary @test.iso -k -u admin:admin https://&lt;pikvm-ip&gt;/api/msd/write?image=test.iso\n</code></pre>"},{"location":"api/#upload-msd-image-by-url","title":"Upload MSD image by URL","text":"<p>The <code>POST /api/msd/write_remote</code> handle downloads an image from HTTP(S) URL to the MSD.</p> <p>Parameters:</p> <ul> <li><code>url=...</code> - Image URL.</li> <li><code>image=...</code> (optional) - Image name.</li> <li><code>timeout=N</code> (optional) - Remote request timeout, 10 seconds by default.</li> </ul> <p>Note</p> <p>This is a long-polling request. Do not interrupt the request until the download is complete, otherwise the download will stop.</p> <pre><code>$ # create test image\n$ dd if=/dev/zero of=test.iso bs=1M count=1\n\n$ # upload it to pikvm\n$ curl -v -X POST -k -u admin:admin https://&lt;pikvm-ip&gt;/api/msd/write_remote?url=http://example.com/test.iso\n</code></pre>"},{"location":"api/#set-msd-parameters","title":"Set MSD parameters","text":"<p>The <code>POST /api/msd/set_params</code> handle changes the current image and/or set drive parameters</p> <p>Parameters:</p> <ul> <li><code>image=...</code> (optional) - Change the current image.</li> <li><code>cdrom=1|0</code> (optional) - Change the media type to the CD-ROM on <code>1</code>, otherwise to the Flash.</li> </ul> <pre><code>$ curl -X POST -k -u admin:admin \"https://&lt;pikvm-ip&gt;/api/msd/set_params?image=test.iso&amp;cdrom=1\"\n</code></pre>"},{"location":"api/#control-msd","title":"Control MSD","text":"<p>The <code>POST /api/msd/set_connected</code> connects or disconnect the MSD to the host.</p> <p>Parameters:</p> <ul> <li><code>connected=1|0</code> - Change the state.</li> </ul> <pre><code>$ curl -X POST -k -u admin:admin https://&lt;pikvm-ip&gt;/api/msd/set_connected?connected=1\n</code></pre>"},{"location":"api/#remove-msd-image","title":"Remove MSD image","text":"<p>The <code>POST /api/msd/remove</code> handle removes the specified image.</p> <p>Parameters:</p> <ul> <li><code>image=...</code> - The image name.</li> </ul> <pre><code>$ curl -X POST -k -u admin:admin https://&lt;pikvm-ip&gt;/api/msd/remove?image=test.iso\n</code></pre>"},{"location":"api/#reset-msd","title":"Reset MSD","text":"<p>The <code>POST /api/msd/reset</code> handle resets the drive.</p> <pre><code>$ curl -X POST -k -u admin:admin https://&lt;pikvm-ip&gt;/api/msd/reset\n</code></pre>"},{"location":"api/#gpio","title":"GPIO","text":""},{"location":"api/#get-gpio-state","title":"Get GPIO state","text":"<p>The <code>GET /api/gpio</code> handle shows the current GPIO state.</p> <pre><code>$ curl -k -u admin:admin https://&lt;pikvm-ip&gt;/api/gpio\n</code></pre>"},{"location":"api/#switch-gpio-channel","title":"Switch GPIO channel","text":"<p>The <code>POST /api/gpio/switch</code> handle interacts with selected GPIO driver channel in <code>switch</code> mode.</p> <p>Parameters:</p> <ul> <li><code>channel=...</code> - The GPIO driver channel.</li> <li><code>state=1|0</code> - The new switch state.</li> <li><code>wait=1</code> (optional) - Says if call should return immediately or just after finishing operation.</li> </ul>"},{"location":"api/#pulse-gpio-channel","title":"Pulse GPIO channel","text":"<p>The <code>POST /api/gpio/pulse</code> handle interacts with selected GPIO driver channel in <code>pulse</code> mode.</p> <p>Parameters:</p> <ul> <li><code>channel=...</code> - The GPIO driver channel.</li> <li><code>delay=N.N</code> (optional) - The pulse time in seconds (float), <code>0</code> for default delay.</li> <li><code>wait=1</code> (optional) - Says if call should return immediately or just after finishing operation.</li> </ul>"},{"location":"api/#misc","title":"Misc","text":""},{"location":"api/#get-prometheus-metrics","title":"Get Prometheus metrics","text":"<p>The <code>GET /api/export/prometheus/metrics</code> handle returns the Prometheus metrics. Also see here for details.</p> <pre><code>$ curl -k -u admin:admin https://&lt;pikvm-ip&gt;/api/export/prometheus/metrics\n</code></pre>"},{"location":"api/#to-be-continued","title":"To be continued ===&gt;","text":"<p>You can find all existing APIs in the KVMD source tree. We would appreciate your help with documentation.</p>"},{"location":"arduino_hid/","title":"Arduino HID (USB, PS/2)","text":""},{"location":"arduino_hid/#using-arduino-hid-on-non-v0-platform","title":"Using Arduino HID on non-V0 platform","text":"<p>This is useful if you need a simple and primitive keyboard/mouse emulator device. For example when used with a hardware KVM switch which does not recognize composite HID. You can also use the Arduino HID to emulate the PS/2 keyboard.</p>"},{"location":"arduino_hid/#serial-hid","title":"Serial HID","text":"<p>PiKVM V3 HAT note</p> <p>Don't use it, use SPI HID for V3. Otherwise, you won't be able to use the Serial console.</p>"},{"location":"arduino_hid/#usb-keyboard-and-mouse","title":"USB keyboard and mouse","text":"<ol> <li> Get some parts <ul> <li>Arduino Pro Micro (based on an ATMega32u4).</li> <li>Logic level shifter.</li> <li>1x NPN transistor (almost any NPN transistor: 2n2222 or similar).</li> <li>1x 390 Ohm resistor.</li> <li>A breadboard and wires.</li> </ul> </li> <li> Build the Arduino HID according to the scheme </li> <li> <p>Power up PiKVM and switch it to RW-mode using command <code>rw</code>.</p> </li> <li> <p>Add these lines to <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>kvmd:\nhid:\ntype: serial\nreset_pin: 4\ndevice: /dev/kvmd-hid\n</code></pre> </li> <li> <p>Create file <code>/etc/udev/rules.d/99-kvmd-extra.rules</code>:</p> <pre><code>KERNEL==\"ttyAMA0\", SYMLINK+=\"kvmd-hid\"\n</code></pre> </li> <li> <p>Run <code>systemctl disable getty@ttyAMA0.service</code>.</p> </li> <li> <p>Remove <code>console=ttyAMA0,115200</code>or <code>console=serial0,115200</code> and <code>kgdboc=ttyAMA0,115200</code> or <code>kgdboc=serial0,115200</code> from <code>/boot/cmdline.txt</code>.</p> </li> <li> <p>Flash the Arduino HID.</p> </li> <li> <p>Perform <code>reboot</code>.</p> </li> </ol>"},{"location":"arduino_hid/#ps2-keyboard","title":"PS/2 keyboard","text":"<p>Using the PS/2 firmware currently have some limitations:</p> <ul> <li>The possibility of using the switchable USB HID is excluded.</li> <li>PS/2 mouse is not supported right now (but it will).</li> </ul> <p>Both of these problems will be solved in the nearest future and the two different firmware versions will be combined into one universal one.</p> <p>To select the PS/2 firmware, follow the instructions for the USB, but with one exception:</p> Before <code>make</code> you will need to edit file <code>platformio-avr.ini</code> <p>Open the file and find these lines:</p> <pre><code>[_common]\nbuild_flags =\n-DHID_PS2_KBD_CLOCK_PIN=7\n-DHID_PS2_KBD_DATA_PIN=5\n-DHID_USB_CHECK_ENDPOINT\n# ----- The default config with dynamic switching -----\n-DHID_DYNAMIC\n-DHID_WITH_USB\n-DHID_SET_USB_KBD\n-DHID_SET_USB_MOUSE_ABS\n# ----- PS2 keyboard only -----\n#   -DHID_WITH_PS2\n#   -DHID_SET_PS2_KBD\n# ----- PS2 keyboard + USB absolute mouse -----\n#   -DHID_WITH_USB\n#   -DHID_WITH_PS2\n#   -DHID_SET_PS2_KBD\n#   -DHID_SET_USB_MOUSE_ABS\n# ----- PS2 keyboard + USB relative mouse -----\n#   -DHID_WITH_USB\n#   -DHID_WITH_PS2\n#   -DHID_SET_PS2_KBD\n#   -DHID_SET_USB_MOUSE_REL\n</code></pre> <p>By default, the firmware works with USB HID and supports dynamic mode switching. You can choose one of the other modes by commenting some lines and uncommenting others. This example to use a USB mouse and PS/2 keyboard:</p> <pre><code>...\n# ----- The default config with dynamic switching -----\n#   -DHID_DYNAMIC\n#   -DHID_WITH_USB\n#   -DHID_SET_USB_KBD\n#   -DHID_SET_USB_MOUSE_ABS\n# ----- PS2 keyboard only -----\n...\n# ----- PS2 keyboard + USB absolute mouse -----\n-DHID_WITH_USB\n-DHID_WITH_PS2\n-DHID_SET_PS2_KBD\n-DHID_SET_USB_MOUSE_ABS\n# ----- PS2 keyboard + USB relative mouse -----\n...\n</code></pre> <p>Next, connect Arduino pins to the female PS/2 port of your motherboard. Choose the purple port. If your motherboard only have one port, it's probably universal and can be used either for the keyboard or for the mouse. Most likely, it is painted in two colors: green and purple. You can use it either.</p> Follow the diagram Female PS/2 port (front view) Pinout Arduino pin 7 &lt;-&gt; PS/2 CLOCKArduino pin 5 &lt;-&gt; PS/2 DATAArduino GND pin &lt;-&gt; PS/2 GND <p>Warning</p> <p>Connect VIN pin of Arduino to any Raspberry's 5v pin for PS/2 only device. But you don't need to connect the Arduino VIN pin if you connected USB (Arduino will get power through it).</p>"},{"location":"arduino_hid/#spi-hid","title":"SPI HID","text":"<p>Using an SPI connection, an Arduino Micro (not Pro) or compatible can be flashed from the Pi and used as an HID keyboard and mouse. Unlike UART, SPI does not share pins with Bluetooth on the Raspberry Pi so the Bluetooth radio does not need to be disabled.</p> <p></p> <p>Before powering either device, double-check the connections. The following should be wired from the Pi to either the level shifter or the Arduino. While the Arduino tolerates 3.3V logic input, 5V outputs from the Arduino can damage or destroy the Raspberry Pi and must not be connected directly to 3.3V GPIO pins directly.</p>"},{"location":"arduino_hid/#parts-list","title":"Parts list","text":"<p>There are very few parts needed besides the Raspberry Pi to build the solution. Some parts may be purchased with or without headers, if headers are not pre-soldered, it may be necessary to order some breakaway header strips and solder them to the boards prior to assembly unless the wires will be soldered directly to the boards.</p> <ul> <li>Raspberry Pi Zero W or Pi 4 are the most popular boards for this solution, pre-soldered headers recommended</li> <li>Arduino Micro (or compatible) microcontroller board with pre-soldered headers recommended</li> <li>Logic Level Converter. This may be RX/TX, Bidirectional, or Single Supply</li> <li>1x PNP transistor (2n2907 or equivalent).  Note this is different from the one suggested in the Serial HID docs above, that is an NPN while this is a PNP.</li> <li>1x 390 ohm resistor</li> <li>Dupont wires (female to male pin) recommended for breadboard or other suitable means of making the connections</li> <li>Optional: Breakaway headers for the logic level converter</li> <li>Optional: Breadboard large enough to accommodate the parts</li> <li>Optional: Header pins for connection to a breadboard</li> </ul> <p>Note</p> <p>A smaller \"Pro Micro\" board is available in a 3.3V model but the SS connection (RX_LED) is not available as a separate pin or solderable hole. If using this board, a jumper wire can be soldered to the resistor for the RX_LED but there is risk of burning the resistor, the LED, the board, or other components in the process. Advantages of this board include not requiring a logic level converter and reduced breadboard or board space for building the solution.</p>"},{"location":"arduino_hid/#list-of-connections-to-be-made","title":"List of connections to be made","text":"<p>For the primary functionality, most connections are made using a 4-channel bidirectional level shifter</p> <ul> <li>Pi 3v3 to LV on the level shifter</li> <li>Pi Ground to LV GND</li> <li>Arduino GND to HV GND</li> <li>GPIO10 (MOSI) via the level shifter to MOSI on the Arduino</li> <li>GPIO9 (MISO) via the level shifter to MISO on the Arduino</li> <li>GPIO11 (SPIO_SCLK) via the level shifter to SCK on the Arduino</li> <li>GPIO7 (SPIO_CE1_N) via the level shifter to SS (or RX_LED) on the Arduino</li> </ul> <p>An additional circuit is used with a transistor to reset the HID for mode changes and for SPI programming as follows:</p> <ul> <li>GPIO25 to PNP base on transistor</li> <li>PNP emitter to ground</li> <li>PNP collector to  RST on the Arduino</li> </ul> <p>Pictures of this setup are also available in full resolution for download to assist for both the Raspberry Pi and the Arduino board. A smaller version of the images has been included on this page and can be downloaded.</p> Raspberry Pi Closeup Breadboard with Arduino <p>Programming assumes the Arduino is powered via USB, either from the connected host or the Pi itself. If the USB is not connected, 5 V may be provided by the Raspberry Pi GPIO but should be disconnected prior to connecting USB to the Arduino's USB port. The Raspberry Pi does not have backcurrent protection, a circuit using one or more Schottky diodes can be built to OR power from multiple sources but it's easier and more cost effective to avoid conflict and voltage differences between power supplies by leaving the 5 V wire disconnected.</p>"},{"location":"arduino_hid/#preparing-the-installation-for-spi-devices-and-programming","title":"Preparing the installation for SPI devices and programming","text":"<p>As of the latest package release, the kdmd service supports SPI. It should be sufficient to ensure the packages are up-to-date with the latest release, the programmer is installed, and the SPI device overlay is loaded at boot.</p> <ul> <li>Switch the filesystem to read-write mode with <code>rw</code></li> <li>Update the system and nstall the avrdude programmer <code>pacman -Syu avrdude-svn</code></li> <li>Add <code>dtoverlay=spi0-1cs</code> to <code>/boot/config.txt</code></li> <li>Reboot with <code>reboot</code> or <code>systemctl reboot</code></li> </ul>"},{"location":"arduino_hid/#flashing-the-arduino","title":"Flashing the Arduino","text":"<p>Instructions on flashing the Arduino can be found on the page Flash the Arduino HID.</p> <p>If programming fails, ensure the Arduino is powered and check the wiring again. If there is a misconfiguration, power off the Pi and the Arduino, correct the wiring, and try again. Note it is not recommended or required to supply 5V power from the Raspberry Pi if the Arduino is USB powered, if the issue appears to be power related it may be removed from the solution and replaced with a powered USB connection if it will aid in troubleshooting but check all other wires first to ensure there are no shorts.</p> <p>After you have double and triple-checked your wiring (in particular make sure the pins you are using on the Pi are correct, the documentation uses the GPIO pin labels, NOT the sequential pin numbers from 1-40. A good pinout reference is @Gadgetoid's version, you might try flashing the Arduino by holding down the RESET button on the chip while running <code>make install</code>.  If this works, then at least you know your SPI wiring is correct.</p> <p>Wiring problems are a common issue but there could be other reasons for programming not to complete. While it is not possible to list every possible problem and solution here, there is an active user community in our Discord with others familiar with the solution and willing to help.</p>"},{"location":"arduino_hid/#enable-the-spi-configuration-and-restart-kvmd","title":"Enable the SPI configuration and restart kvmd","text":"<p>Once the installation has completed, all that should remain is to add the following configuration to <code>/etc/kvmd/override.yaml</code> and restart the kvmd service. If the first line exists due to existing overrides, omit that line and either add or update the hid section as appropriate.</p> <pre><code>kvmd:\nhid:\ntype: spi\nchip: 0\nbus: 0\nsw_cs_pin: 7\nreset_pin: 25\nreset_inverted: true\n</code></pre> <p>After saving the changes to <code>/etc/kvmd/override.yaml</code>, restart <code>kvmd</code> and clear your browser cache. The command to restart <code>kvmd</code> is</p> <pre><code># systemctl restart kvmd\n</code></pre> <p>If your device is still in read-write mode, <code>ro</code> will put the SD back in read-only mode.</p>"},{"location":"arduino_hid/#fixing-the-usb-absolute-mouse-on-windows-98","title":"Fixing the USB absolute mouse on Windows 98","text":"<p>Due to an ancient buggy driver, the USB absolute mouse on Windows 98 moves only within the upper-left quarter of the screen. To fix this, just recompile the firmware with uncommented flag <code>-DHID_WITH_USB_WIN98</code> in <code>platformio-avr.ini</code>.</p>"},{"location":"atx_board/","title":"ATX control board","text":""},{"location":"atx_board/#atx-control-board","title":"ATX control board","text":"<p>To manage the power of your computer, you will need to install an ATX adapter board inside the case and connect it to the motherboard. There is a female to female ribbon cable that goes from the motherboard to the ATX adapter board and a male to female ribbon cable that goes from the adapter board to the front panel ribbon cable. There are two rows of pins on the ATX adapter board, it does not matter which ribbon cable is attached to which row. The columns must line up from the front panel through the ATX adapter to the motherboard.</p> <p>Apple's Mac computers are not ATX compatible as they lack the needed ATX headers, this is ONLY compatible with PC servers and desktops.</p>"},{"location":"atx_board/#detailed-instructions","title":"Detailed instructions","text":"<ol> <li> <p>Connect the rainbow wires to the board, one row to the front panel, one row to the motherboard. You can use either row for either cable. To secure the ATX board in the case you can optionally print the mounting plate for the PCI slot on a 3D-printer. Assemble everything like the pictures below. Secure wires in any convenient way (we used soft ties).</p> Example <p></p> <p></p> <p></p> </li> <li> <p>Find the pins on the motherboard responsible for connecting the buttons and LEDs of the front panel of the case. Usually wires and connectors on the motherboard have designations. If you're not sure, check the documentation on your motherboard.</p> Example <p></p> <p></p> </li> <li> <p>Place the ATX board nearby and, focusing on the labels and polarity (+ or -), connect the male pins to the female pin of the front panel wires. Be sure to align the labels and polarity (the polarity is indicated on the ATX board).</p> Example <p></p> </li> <li> <p>Repeat the procedure with the female pin of the ATX board by connecting them to the motherboard connector. Check the documentation on your motherboard to find out which pin on the motherboard goes to which pin on the ATX adapter. Sometimes it is printed on the motherboard.</p> Example <p></p> </li> <li> <p>Install the ATX board into the PCI slot of the case and fix it with a screw, or use a different mounting method at your discretion.</p> Example <p></p> <p></p> </li> <li> <p>Arrange the wires in a way that is convenient for you and fix them if necessary. Ensure the cables do not come into contact with any fans in your case.</p> Example <p></p> </li> <li> <p>Connect the ATX board to PiKVM using a straight Ethernet cable. 2 pair/4 wire will NOT work, must be a 4 pair/8 wire.</p> Example <p></p> </li> </ol>"},{"location":"atx_board/#pinout","title":"Pinout","text":"ATX RJ-45 pinout <p>The pinout of the RJ-45 connector is the same on the AT and ATX adapter.</p> <p></p> ATX LED wiring example <p></p>"},{"location":"audio/","title":"HDMI audio","text":""},{"location":"audio/#pikvm-v3-audio","title":"PiKVM V3+ Audio","text":"<p>This feature allows you to receive audio over an HDMI cable and transmit it to the browser in WebRTC mode.</p> <p>Warning</p> <ul> <li>This is only supported by PiKVM V3+ devices right now. This may or may not work on other CSI devices as most have a hw defect.</li> <li>Please note the feature is experimental. Nothing will explode for you, but something may not work. Please report about problems here (preferred) or here.</li> <li>KVM switches may or may not work, we currently do not have a list of what works due to the feature being new/experimental.</li> <li>MIC support is not supported at this time, it may be supported in the future.</li> </ul> <p>Info</p> <p>PiKVM V4 has enabled this feature by default.</p>"},{"location":"audio/#preparing","title":"Preparing","text":"<ol> <li> <p>Make sure that you have not removed the jumpers related to audio (4) on the V3 board and have not deleted or commented out the <code>dtoverlay=tc358743-audio</code> line in <code>/boot/config.txt</code>. Return everything as it was, if you changed it. For V4 you can skip this step.</p> </li> <li> <p>Update the OS:    </p><pre><code># rw\n# pacman -Syu\n</code></pre> </li> <li> <p>Edit <code>/etc/kvmd/janus/janus.plugin.ustreamer.jcfg</code> and add the following lines at the end:    </p><pre><code>audio: {\n    device = \"hw:0,0\"\n    tc358743 = \"/dev/kvmd-video\"\n}\n</code></pre> </li> <li> <p>Enable the basic audio in the EDID:    </p><pre><code># kvmd-edidconf --set-audio=yes\n</code></pre> </li> <li> <p>Reboot the device:    </p><pre><code># reboot\n</code></pre> </li> <li> <p>Your host will detect the possibility of audio output via HDMI. Mac OS usually connects automatically, Windows requires manual indication, Linux will require a ritual shamanic dance. In any case, make sure that the audio is output via HDMI on your host. PiKVM supports stereo mode with any standard bits and frequencies like 32/44.1/48 kHz with 16/24 bit.</p> </li> <li> <p>Open the PiKVM Web UI. Click the System menu and switch the video mode to H.264 / WebRTC. After that, the volume slider will appear under the switch. Increase it to the maximum and have fun.</p> </li> </ol> <p>Warning</p> <ul> <li>After the page is reloaded, the audio slider will be reset. This is a technical limitation in all browsers to avoid annoying audio ads.</li> <li>If something doesn't work, check the log: <code>journalctl -u kvmd-janus</code>.</li> <li>Try a different browser, try and clear browser cache before reporting issues.</li> <li>Unplug the hdmi cable and plug back in, either from the PiKVM end and or the target end.</li> <li>Please report about problems here (preferred) or here.</li> </ul>"},{"location":"auth/","title":"Authentication","text":""},{"location":"auth/#authentication","title":"Authentication","text":"<p>PiKVM comes with the following default passwords:</p> <ul> <li>Linux admin (SSH, console, etc.): user <code>root</code>, password <code>root</code>.</li> <li>PiKVM Web Interface, API, VNC...: user <code>admin</code>, password <code>admin</code>, no 2FA code.</li> </ul> <p>These are two separate entities with independent accounts. To change passwords, you will need to use the terminal access via SSH or Web Terminal. If you are using the Web Terminal, use the <code>su -</code> command to get root access (enter the root user password).</p>"},{"location":"auth/#changing-the-linux-password","title":"Changing the Linux password","text":"<pre><code># rw\n# passwd root\n# ro\n</code></pre>"},{"location":"auth/#changing-the-kvm-password","title":"Changing the KVM password","text":"<pre><code># rw\n# kvmd-htpasswd set admin\n# ro\n</code></pre> <p>Please note that admin is the default user. It is possible to create several different users with different passwords to access the Web UI, but keep in mind that they all have the same rights:</p> <pre><code># kvmd-htpasswd set &lt;user&gt; # Sets a new user with password\n# kvmd-htpasswd del &lt;user&gt; # Removes/deletes a user\n</code></pre>"},{"location":"auth/#two-factor-authentication","title":"Two-factor authentication","text":"<p>This is a new method of strengthening the protection of PiKVM, available since <code>KVM &gt;= 3.196</code>. It is strongly recommended to enable it if you expose the PiKVM in the big and scary Internet.</p> <p>Warning</p> <p>Using 2FA eliminates the possibility of using IPMI and VNC with vncauth (not used by default). It also slightly affects the use of API and regular VNC with user/password, read below.</p> <p>Steb-by step to enable 2FA:</p> <ol> <li> <p>Update OS: <code>rw &amp;&amp; pacman -Syu &amp;&amp; reboot</code>.</p> </li> <li> <p>Make sure that NTP is running otherwise you will not be able to access (<code>timedatectl</code> command). The timezone doesn't matter.</p> </li> <li> <p>Install Google Authenticator app to your phone (iOS, Android). It will generate one-time access codes.</p> </li> <li> <p>Create a secret for one-time codes on PiKVM:    </p><pre><code>rw\nkvmd-totp init\nro\n</code></pre> </li> <li> <p>Run Google Authenticator and scan the QR code.</p> </li> <li> <p>Now, on the PiKVM login page, you will need to add 6 digits to the 2FA code field.</p> </li> </ol> <p>Now all Web UI users will be required to enter a one-time password. In other words, the secret is the same for all users.</p> <p>Note</p> <p>With 2FA for API or VNC authentication, you will need to add the one-time code to the password without spaces. That is, if the password is <code>foobar</code> and the code is <code>123456</code>, then you need to use <code>foobar123456</code> as the password.</p> <p>To view the current QR code of the secret use <code>kvmd-totp show</code>.</p> <p>To disable 2FA, use <code>kvmd-totp del</code>.</p>"},{"location":"bluetooth_hid/","title":"Bluetooth HID","text":""},{"location":"bluetooth_hid/#bluetooth-hid","title":"Bluetooth HID","text":"<p>PiKVM is able to emulate a Bluetooth keyboard &amp; mouse. This is not the main case of using PiKVM since you still need it to pair with a remote host, but can be used for something like mobile KVM.</p> <p>Warning</p> <p>Using Bluetooth HID requires additional configuration of the operating system. For v2+, this means losing the UART port, since it will be used by Bluetooth. Also, Bluetooth operation was tested only on RPi4 and v2+ platform. Other boards may require different system service settings. Making the required changes for BT to work will also disable normal KB/MOUSE functionality therefor this will need to be disabled before normal operation can occur.</p> <p>Note</p> <p>Bluetooth mouse can work only in relative mode. The reason is that many Bluetooth host drivers do not correctly implement HID descriptors. Horizontal scrolling is not supported for the same reason.</p>"},{"location":"bluetooth_hid/#configuring-the-os","title":"Configuring the OS","text":"<ol> <li> <p>Switch filesystem to RW-mode, perform update and install some packages:</p> <pre><code># rw\n# pacman -Syu bluez bluez-utils raspberrypi-bluetooth\n</code></pre> </li> <li> <p>Edit <code>/boot/config.txt</code> and comment these lines:</p> <pre><code>#enable_uart=1\n#dtoverlay=disable-bt\n</code></pre> </li> <li> <p>Create an empty directory <code>/var/lib/bluetooth</code> and add mountpoint to <code>/etc/fstab</code>:</p> <pre><code># mkdir /var/lib/bluetooth\n# echo 'tmpfs /var/lib/bluetooth tmpfs nodev,nosuid,mode=0755 0 0' &gt;&gt; /etc/fstab\n</code></pre> </li> <li> <p>Override and enable the services:</p> <pre><code># mkdir /etc/systemd/system/bluetooth.service.d\n# cat &lt;&lt; EOF &gt; /etc/systemd/system/bluetooth.service.d/override.conf\n[Service]\nExecStart=\nExecStart=/usr/lib/bluetooth/bluetoothd --noplugin=*\nEOF\n# systemctl enable bluetooth\n# systemctl enable raspberrypi-btuart\n</code></pre> </li> <li> <p>Override <code>kvmd</code> service:</p> <pre><code># mkdir /etc/systemd/system/kvmd.service.d\n# cat &lt;&lt; EOF &gt; /etc/systemd/system/kvmd.service.d/override.conf\n[Service]\nAmbientCapabilities=CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SETUID CAP_SETGID CAP_CHOWN\nCapabilityBoundingSet=CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SETUID CAP_SETGID CAP_CHOWN\nEOF\n</code></pre> </li> <li> <p>Add following lines to <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>kvmd:\nhid:\ntype: bt\n</code></pre> </li> <li> <p>Perform <code>reboot</code>.</p> </li> <li> <p>To reverse, uncomment lines from Step 2 and remove lines in Step 6, and <code>reboot</code>.</p> </li> </ol>"},{"location":"bluetooth_hid/#using-bluetooth-hid","title":"Using Bluetooth HID","text":"<ul> <li> <p>After a reboot, the PiKVM will be ready for detection and pairing with no auth. You will see the <code>PiKVM HID</code> device.</p> </li> <li> <p>Once the server is connected, PiKVM will no longer be discoverable and pairable to other clients until you unpair the server.</p> </li> <li> <p>If something went wrong, use the web menu <code>System -&gt; Reset keyboard &amp; mouse</code>. This will cause unpair the device and switch the PiKVM to public mode before the first client is connected.</p> </li> </ul>"},{"location":"building_os/","title":"Building PiKVM OS","text":""},{"location":"building_os/#building-the-os","title":"Building the OS","text":"<p>ZeroW reached End-Of-Life and is no longer supported, the last image it can be found here</p> <p>The PiKVM OS is based on Arch Linux ARM and contains all the required packages and configs for it to work. To build the OS you will need x86_64 Linux machine with:</p> <ul> <li>kernel &gt;= 5.8</li> <li>glibc &gt;= 2.33</li> <li>docker &gt;= 19.03.13</li> </ul> <p>Docker must be enabled in privileged mode.</p> <ol> <li> <p>When starting with a clean OS you need to install and configure docker (after adding your user to the docker group you must log out and log back in), as well as git and make. An example for Ubuntu:</p> <pre><code>[user@localhost ~]$ sudo apt-get install git make curl binutils -y\n[user@localhost ~]$ sudo apt-get install docker.io\n[user@localhost ~]$ sudo usermod -aG docker $USER\n</code></pre> <p>Re-login to apply the changes.</p> </li> <li> <p>Git checkout the build toolchain:</p> <pre><code>[user@localhost ~]$ git clone --depth=1 https://github.com/pikvm/os\n[user@localhost ~]$ cd os\n</code></pre> </li> <li> <p>Determine the target hardware configuration (platform):</p> <ul> <li>Choose the board: <code>BOARD=rpi4</code> for Raspberry Pi 4 or <code>BOARD=zerow</code>, <code>BOARD=rpi2</code>, <code>BOARD=rpi3</code> for other options.</li> <li>Choose the platform:<ul> <li><code>PLATFORM=v4mini-hdmi</code> for PiKVM V4 Mini.</li> <li><code>PLATFORM=v4plus-hdmi</code> for PiKVM V4 Plus.</li> <li><code>PLATFORM=v3-hdmi</code> for RPi4 and PiKVM V3 HAT.</li> <li><code>PLATFORM=v2-hdmi</code> for RPi3a+/RPi4 or Zero2W with HDMI-CSI bridge.</li> <li><code>PLATFORM=v2-hdmiusb</code> for RPi4 with HDMI-USB dongle.</li> <li><code>PLATFORM=v0-hdmi</code> for RPi2 or 3b+ with HDMI-CSI bridge and Arduino HID.</li> <li><code>PLATFORM=v0-hdmiusb</code> for RPi2 or 3b+ with HDMI-USB dongle and Arduino HID.</li> <li>Other options are for legacy or specialized PiKVM boards (WIP).</li> </ul> </li> </ul> </li> <li> <p>Create the config file <code>config.mk</code> for the target system. You must specify the path to the SD card on your local computer (this will be used to format and install the system) and the version of your Raspberry Pi and platform. You can change other parameters as you wish. Please note: if your password contains the # character, you must escape it using a backslash like <code>ROOT_PASSWD = pass\\#word</code>.</p> </li> </ol> <p>!!! warning \"In any case, do not use the default passwords. In order to generate a random password just use following command:\" <code>printf '%s\\n' $(head /dev/urandom | LC_ALL=C tr -dc A-Za-z0-9 | head -c16)</code></p> <pre><code>```Makefile\n[user@localhost os]$ cat config.mk\n# rpi4 for Raspberry Pi 4; rpi3 for Raspberry Pi 3; rpi2 for the version 2, zero2w for Zero2W\nBOARD = rpi4\n\n# Hardware configuration\nPLATFORM = v2-hdmi\n\n# Target hostname\nHOSTNAME = pikvm\n\n# ru_RU, etc. UTF-8 only\nLOCALE = en_US\n\n# See /usr/share/zoneinfo\nTIMEZONE = Europe/Moscow\n\n# For SSH root user\nROOT_PASSWD = root\n\n# Web UI credentials: user=admin, password=&lt;this&gt;\nWEBUI_ADMIN_PASSWD = admin\n\n# IPMI credentials: user=admin, password=&lt;this&gt;\nIPMI_ADMIN_PASSWD = admin\n\n# SD card device\n# (Used for burning the image with `make install`. Irrelevant if you only use `make image`.)\nCARD = /dev/mmcblk0\n```\n</code></pre> <ol> <li> <p>Build the OS. It may take about one hour depending on your Internet connection:</p> <pre><code>[user@localhost os]$ make os\n</code></pre> </li> </ol> <p>If you get an error about failing to retrieving a file, please edit the Makefile and remove \"de3.\" from the repo path</p> <ol> <li> <p>One of two actions:</p> <ul> <li> <p>Put SD card into card reader and install OS (you should disable automounting beforehand: <code>systemctl stop udisk2</code> or something like that):</p> <pre><code>[user@localhost os]$ make install\n</code></pre> </li> <li> <p>Or make the image only. You can then later burn it on an SD card (e.g. using the Raspberry Pi Imager, see article Flashing the OS image):</p> <pre><code>[user@localhost os]$ make image\n</code></pre> <p>Image is then available as xz compressed file in <code>images/</code>.</p> </li> </ul> </li> </ol> <p>On a system where <code>sudo</code> is unavailable, you can use <code>make SUDO= image</code>.</p>"},{"location":"cloudflared/","title":"Cloudflare Tunnel","text":""},{"location":"cloudflared/#cloudflare-tunnels","title":"Cloudflare Tunnels","text":"<p>Cloudflare Tunnels can be used to access PiKVM over the internet securely using Cloudflare Zero Trust with the <code>cloudflared</code> daemon. This is a convenient and free (for private use) tool for allowing access to web services running on your internal network without port forwarding or IPv4/IPv6 compatability issues. This document is provided as an example for accessing your PiKVM over the internet but you can also use Zerotier/Tailscale/Insert XYZ VPN service here. Basic support like whats shown below is provided as an example, any other setting or functionality needs to be redirected to the appropriate community.</p>"},{"location":"cloudflared/#prequisites","title":"Prequisites","text":"<ol> <li> <p>A domain utilizing Cloudflare for DNS</p> </li> <li> <p>A Cloudflare tunnel configured with an application created and secured by an access policy</p> </li> </ol>"},{"location":"cloudflared/#cloudflare-tunnel-steps","title":"Cloudflare Tunnel Steps","text":"<ol> <li> <p>Login to Cloudflare and provision a tunnel using the steps here. Save the tunnel token as we will need this later. In most cases the target will be https://localhost </p> </li> <li> <p>Create a self-hosted application with the URL matching one created in the previous step by following the steps here. </p> </li> <li> <p>You will need to check the http options to disable SSL certificate verification under <code>Tunnels -&gt; Configure -&gt; Public Hostname -&gt; yourapplication.yourdomain -&gt; Edit -&gt; TLS Settings -&gt; No TLS Verify</code> as the PiKVM uses self-signed certificates.</p> </li> <li> <p>Don't skip the access policies as this important to preventing randoms from the internet from gaining access to your PiKVM. Cloudflare offers a variety of login options with the simplest being One-time PINs that are emailed to you. NOTE: This external authentication will not replace the username/password for the PiKVM but instead supplement it acting as a first line of defense from the internet.</p> </li> </ol>"},{"location":"cloudflared/#installation","title":"Installation","text":"<p>Unfortunately Cloudflare does not provide binaries for ARM so we need to compile from source to generate a working build. </p>"},{"location":"cloudflared/#on-the-pikvm-side","title":"On the PiKVM side","text":"<ol> <li> <p>Use these commands:</p> <pre><code># rw\n# pacman -Syu go\n# curl -s https://api.github.com/repos/cloudflare/cloudflared/releases/latest | grep \"tarball_url\" | cut -d '\"' -f 4 | xargs curl -LJo cloudflared-latest.tar.gz\n# tar -xzvf cloudflared-latest.tar.gz --transform 's|[^/]*/|cloudflared/|'\n# cd cloudflared/cmd/cloudflared/\n# go build\n# mv cloudflared /usr/bin/cloudflared\n# cloudflared version\n</code></pre> </li> <li> <p>Create the service configuration file</p> <pre><code># systemctl edit --full cloudflared.service\n</code></pre> </li> <li> <p>Insert the following configuration replacing TOKEN VALUE with your token from the Cloudflare tunnel step.</p> <pre><code>[Unit]\nDescription=Cloudflare Tunnel\nAfter=network.target\n\n[Service]\nTimeoutStartSec=0\nType=notify\nExecStart=/usr/bin/cloudflared --protocol quic tunnel run --token &lt;TOKEN VALUE&gt;\nRestart=on-failure\nRestartSec=5s\n</code></pre> </li> <li> <p>Afterwards verify service is started and stays running</p> <pre><code># systemctl enable --now cloudflared\n# systemctl status cloudflared\n</code></pre> </li> <li> <p>Open a web browser and attempt</p> </li> </ol>"},{"location":"cloudflared/#updating-cloudflared","title":"Updating cloudflared","text":"<p>Use these commands to update the <code>cloudflared</code> daemon:</p> <pre><code># rw\n# rm -rf cloudflared/\n# curl -s https://api.github.com/repos/cloudflare/cloudflared/releases/latest | grep \"tarball_url\" | cut -d '\"' -f 4 | xargs curl -LJo cloudflared-latest.tar.gz\n# tar -xzvf cloudflared-latest.tar.gz --transform 's|[^/]*/|cloudflared/|'\n# cd cloudflared/cmd/cloudflared/\n# go build &amp;&amp; mv cloudflared /usr/bin/cloudflared\n# systemctl restart cloudflared\n</code></pre>"},{"location":"community_faq/","title":"Community faq","text":""},{"location":"community_faq/#most-of-the-official-instuctions-or-tips-and-tricks-have-been-migrated-to-the-official-faq-the-less-official-items-will-remain-in-this-faq-till-otherwise-removed","title":"Most of the official instuctions or tips and tricks have been migrated to the official FAQ, the less official items will remain in this FAQ till otherwise removed.","text":""},{"location":"community_faq/#can-you-have-the-pikvmrpi4-connected-along-with-a-monitor","title":"Can you have the pikvm(RPi4) connected along with a monitor?","text":"<ul> <li>A community member has had success with the following: https://www.amazon.com/gp/product/B08DQWLXF1</li> <li>Some Alternitives</li> <li>If you have two outputs, you may be able to use screen mirroring from the OS but not BIOS</li> <li>If you have one output or need access from both a local monitor or PiKVM at boot time, one of the following options may work:</li> <li>Passthrough HDMI capture devices (sometimes referred to as a loop capture device). The Elgato and Avermedia devices DO NOT WORK! Look for Linux OS support when choosing a device, the expected price range is about $35-$70 US.</li> <li>Depending on your capture device, an HDMI splitter may work but will need what is called an EDID (Extended Device ID) generator, the monitor and capture device both generate EDID so the splitter must produce its own separate EDID for the host.</li> <li>Look for HDMI splitters - although there have been reports that these are not stable<ul> <li>Please use the search function in Discord, some users have had sucess in getting this to work but your mileage may vary</li> </ul> </li> <li>The better solution is to capture the stream in a dir and then use VLC to stream to that capture on another computer. This will result in fps loss.</li> </ul>"},{"location":"community_faq/#i-want-to-do-something-not-related-to-pikvm","title":"I want to do something not related to PiKVM","text":"<ul> <li>It's recommended that you review Arch documents related to what you want to do, while there are several folks in discord who can help, there is no obligation...they do it for the feels. So if you don't get an answer within the time frame you are looking for, it's advised you start google searching for what you want.</li> </ul>"},{"location":"community_faq/#can-this-be-used-in-any-other-distros-like-rasbian-run-this-in-a-docker","title":"Can this be used in any other distro\u2019s like Rasbian? Run this in a Docker?","text":"<ul> <li>Officially, no. Unofficially yes and totally #unsupported. Please DM @srepac on discord for the directions.</li> <li>Docker image is available, search the docker hub but this is #unsupported and #unofficial and not updated.</li> </ul>"},{"location":"community_faq/#can-you-switch-from-usb-to-csi-or-from-csi-to-usb","title":"Can you switch from USB to CSI or from CSI to USB?","text":"<ul> <li>Officially, no. You would be advised to make 2 seperate SD cards and swap them when needed. Unofficially yes and totally NOT supported. Please DM @srepac on discord for the script and directions.</li> </ul>"},{"location":"community_faq/#help-i-ran-out-of-space-aka-room-what-now","title":"Help! I ran out of space aka room! What now?","text":"<p>(This ONLY applies to the older flashed images and is no longer nessessary as the newer images had the main partition increased, as a result, the MSD partition was shrunk) - You\u2019ve cached package updates you no longer need. - Enter read/write mode by executing rw as root - Execute the following as root to clear the package cache </p><pre><code>rm -rf /var/cache/pacman/pkg/*\n</code></pre> - Exit read/write mode by executing ro as root - You can also use gparted to resize partitions without \"losing data\", although there is a chance this may delete all of your data"},{"location":"community_faq/#can-you-connect-a-camera-to-this-and-still-make-pikvm-functional","title":"Can you connect a camera to this and still make pikvm functional?","text":"<ul> <li>Yes, any low cost no name webcam can be used in place of the usb dongle, please use the usb image</li> <li>A PiCam will NOT work</li> </ul>"},{"location":"community_faq/#help-something-isnt-working","title":"HELP!! Something isn't working!!","text":"<ul> <li>What was the last thing or most recent thing you did? Did you undo it?</li> <li>Did you change a file? Did you back it up before changing it?</li> <li>Did you hook this to anything else? If not why not?</li> <li>Did you try different cables?</li> </ul>"},{"location":"community_faq/#things-to-do-after-initial-install","title":"Things to do after initial install:","text":"<ul> <li>Fix date: 'timedatectl list-timezones' then 'timedatectl set-timezone America/Los_Angeles' (Change to your location)</li> <li>Update PiKVM, follow #news on Discord for instructions</li> <li>Setup a NFS share to give read/write storage on the read only pikvm</li> <li>Note: this does assume you already have an NFS server on your network and accessible to pikvm</li> <li>Source https://linuxhint.com/install_configure_nfs/ <pre><code>pacman -S nfs-utils\nshowmount -e 192.168.1.XXX\nmount -t nfs 192.168.1.XXX:/volume1/Data /mnt/Data\nnano /etc/fstab\n</code></pre>   Add To the bottom of the file <pre><code>192.168.1.XXX:/volume1/Data /mnt/Data nfs      auto,rw,soft    0 0\n</code></pre></li> </ul>"},{"location":"community_faq/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>:exclamation:It is expected that you are aware of basic networking while working on this project and that you have read up on the project prior to going to Discord:exclamation:</li> <li>Do you know the IP?</li> <li>Can you ping the IP?</li> <li>Did you swap cables?</li> <li>Did you swap the eth port to a known working eth port?</li> <li>Do you have access to another router or switch?</li> <li>Did you change ports on the router/switch?</li> <li>RPi4 - Did you hook up a monitor? Once logged in, can you ping to your gateway? Other IP's on the same network?</li> <li>Did you connect a monitor to the target? Does it work?</li> <li> <p>Did you connect the PIKVM to the target directly? Does it work?</p> </li> <li> <p>Reboot target</p> </li> <li>Try default image, do not update and test</li> </ul> <p>-copy/paste into a file, call it pi-info.sh, chmod +x pi-info.sh, ./pi-info.sh Same script is located here </p><pre><code>#!/bin/bash\nuptime\nTMPFILE=\"/tmp/pacmanquery\"; /bin/rm -f $TMPFILE\npacman -Q | awk '{print $2, $1}' &gt; $TMPFILE\nchmod go+w $TMPFILE\n\npistat &amp;&amp; echo\n\nprintf \"%-18s\\t%s\\n\" \"Version\" \"Package-Name\" \"----------------------\" \"-----------------------------\"\n\nPACKAGES=\"firmware bootloader kvmd ustreamer nginx wpa wireless\"\nfor PKG in $( echo $PACKAGES ); do\n        printf \"%-18s\\t%s\\n\" $(grep $PKG $TMPFILE | sed 's/-[1-9]//g')\ndone\n</code></pre> <code>dmesg | grep tc35</code> - CSI  <code>dmesg | egrep '1-1.[245]|uvc'</code> - USB <p><code>systemctl status kvmd</code></p> <p><code>systemctl status kvmd-otg</code></p> <ul> <li> <p>hint:  look at kvmd-platform line of the output... make sure it matches the image they expect for the capture device and platform</p> </li> <li> <p>Keyboard/Mouse icons orange? Try a different cable (ALLOT are power only), try a different usb port</p> </li> <li> <p>Should see the following if everything is in place <code>ls -l /dev/kvmd</code> </p><pre><code>lrwxrwxrwx 1 root root 5 Apr  5 21:33 /dev/kvmd-hid-keyboard -&gt; hidg0\nlrwxrwxrwx 1 root root 5 Apr  5 21:33 /dev/kvmd-hid-mouse -&gt; hidg1\nlrwxrwxrwx 1 root root 6 Mar 15 09:07 /dev/kvmd-video -&gt; video0\n</code></pre> </li> </ul>"},{"location":"community_faq/#common-commands-for-troubleshooting-pikvm","title":"Common Commands for troubleshooting PiKVM","text":"<ul> <li><code>journalctl -u kvmd</code></li> <li><code>journalctl -u kvmd-vnc</code></li> <li><code>journalctl -u kvmd-ipmi</code></li> </ul>"},{"location":"community_faq/#bootuppower-issues","title":"Bootup/power issues","text":"<ul> <li>PiKVM won\u2019t boot past \u201crainbow\u201d screen</li> <li>Are you plugged into the right HDMI port? Needs to be the one next to the power for RPI4</li> <li>Have you reflashed your SD card?</li> </ul>"},{"location":"community_faq/#usb-video-capture-issues","title":"USB Video Capture Issues","text":"<ul> <li>Make sure this is a capture card and not an adapter (HDMI-&gt;USB)</li> </ul>"},{"location":"community_faq/#hdmi-csi-capture-issues","title":"HDMI-CSI Capture issues","text":"<ul> <li>Have you reset the Target PC?</li> <li>Are you sure it's a bridge and not an extender? There is a difference</li> <li>Did you make sure it's plugged into the right port? It needs to say Camera NOT Display</li> <li>Did you try another ribbon cable?</li> <li>Did you reseat the ribbon cable?</li> <li>Is the ribbon cable facing the right way? Needs to be towards the PCB (Green or Black)</li> <li>If you are getting snow looking screen, you need to make sure you select 50hz OR select anything below 1080p, like 720p60</li> <li>If you are getting an Indian looking screen, please clear the browser cache or use private/incog window</li> </ul>"},{"location":"community_faq/#misc-stuff","title":"Misc stuff","text":"<ul> <li>Fully working example of a Pi4 USB-HDMI KVM attached to AIMOS 4-port HDMI KVM switch (8 port is on AliExpress), with keyboard hotkey switching between inputs, and mass storage media emulation on a Pi Zero W</li> <li>PiKVM that mitigates HDMI backpower and requires no splitter board here</li> <li>VERY useful scripts that enhance the PiKVM's functionality - Please DM @srepac on discord to gain access</li> </ul>"},{"location":"community_faq/#useful-links","title":"Useful links","text":"<ul> <li>https://www.tomshardware.com/how-to/kvm-over-ip-raspberry-pi - Very good article on PIKVM setup</li> </ul> <p>As of March 2021, Below are frequently out of Stock or hard to get items, all have exceptionally LONG shipping dates </p> <pre><code>Ezcoo KVM - Goes out of stock frequently\nCSI2-HDMI bridge w/ TC358743XBG chip - Goes out of stock freqently \nAlternative names for the same devices:\nTiamu       Sling           Yazan           Ningwang    Essenc      Geekworm\nFauge       Haudang     AKAT            Docoop          Katigan     Lyusa (recommended by mdevaev)\nLNIMI       cherrypop   Lopbinte    Uang            Tuneway     Mustwell\nFacibom     Binchil     Cobeky      Ctzrzyt         Davitu  \n</code></pre> <ul> <li>Community recommended USB capture card</li> <li>Community recommended Loop device that allows Monitor+PiKVM</li> </ul>"},{"location":"edid/","title":"Tuning HDMI EDID","text":""},{"location":"edid/#edid","title":"EDID","text":"<p>Warning</p> <p>This will only apply to the CSI models include V3+, USB is not compatable. Modifing the EDID may or may not work in some instances where a \"no signal\" might be a result of outside factors.</p> <p>EDID is information about the video modes supported by the video capture device. In the case of PiKVM, this is an HDMI CSI bridge. Usually, you don't need to change this, since the default configuration is quite flexible, but sometimes, for example for strange UEFIs/BIOSes, this may be necessary (the story).</p> <p>The EDID is stored on the PiKVM in the file <code>/etc/kvmd/tc358743-edid.hex</code>. If you write new data there, it will be applied after rebooting.</p> <p>You can also apply the new EDID without rebooting to make sure it works:</p> <ul> <li>Switch filesystem to RW-mode: <code>rw</code>.</li> <li>Create the new EDID file <code>/root/edid.hex</code> (examples of file contents are shown below).</li> <li>Apply EDID using the command <code>kvmd-edidconf --edid=/root/edid.hex --apply</code>.</li> <li>DO NOT REBOOT the PiKVM. Just your PC. Check the UEFI/BIOS.</li> <li>If everything works, you can write the same data to <code>/etc/kvmd/tc358743-edid.hex</code>.</li> <li>Switch filesystem to RO-mode: <code>ro</code>.</li> </ul> <p>The examples below are tested on these devices, but they are also suitable for others. To edit or create EDID you can use AW EDID Editor.</p>"},{"location":"edid/#editing-edid","title":"Editing EDID","text":"<p>To edit EDID, it is best to use third-party utilities, such as the recommended advanced AW EDID Editor for Windows (it's working great in wine) or wxEDID. Both editors work with the binary EDID format, but you can easily import and export it to PiKVM using the <code>kvmd-edidconf</code> utility.</p> <p>So, to tune EDID on PiKVM, use the following steps:</p> <ol> <li> <p>Switch filesystem to RW-mode: <code>rw</code>.</p> </li> <li> <p>Export the system edid to the binary file <code>myedid.bin</code>:    </p><pre><code># kvmd-edidconf --export-bin=/root/myedid.bin\n</code></pre> </li> <li> <p>Copy this file to your PC with the editor. Use SCP, Putty or something like that. Open this binary file in the editor and change the necessary parameters. Edit, save and copy it back to PiKVM.</p> </li> <li> <p>Convert the binary file to the HEX and test it:    </p><pre><code># kvmd-edidconf --import=/root/myedid.bin --edid=/root/myedid.hex --apply\n</code></pre> </li> <li> <p>If everything works fine, install the new EDID file into the system:    </p><pre><code># cp /root/myedid.hex /etc/kvmd/tc358743-edid.hex\n</code></pre> </li> <li> <p>Alternative to step (4) and (5): if you are confident in your abilities, you can immediately install the new <code>myedit.bin</code> into the system and apply it instantly, without the need to use the temporary <code>myedid.hex</code>:    </p><pre><code># kvmd-edidconf --import=/root/myedid.bin --apply\n</code></pre> </li> <li> <p>Switch filesystem to RO-mode: <code>ro</code>.</p> </li> </ol> <p>The <code>kvmd-edidconfig</code> utility has the ability to change some simple parameters without using an external editor. For example you can change the vendor, model name and enable HDMI audio on the PiKVM virtual display:</p> <pre><code># kvmd-edidconf --set-mfc-id=LNX --set-monitor-name=PiKVM --set-audio=1\n# reboot\n</code></pre> <p>Note</p> <p>Windows cache's drivers and registry settings so changing the monitor name is not enough, you will also need to change the product ID and/or the serial number along with the monitor name: <code># kvmd-edidconf --set-monitor-name=TOSHIBA --set-mfc-id=TTP --set-product-id=34953 --set-serial=2290649089 --apply</code></p>"},{"location":"edid/#custom-edids","title":"Custom EDIDs","text":"<p>Copy the contents into a file, ex: myedid.hex then follow the same steps as above starting at step 5.</p> 1280x1024 as preferred. Useful for Gigabyte GA-H77-DS3H <pre><code>00FFFFFFFFFFFF005262888800888888\n1C150103800000780AEE91A3544C9926\n0F505425400001000100010001000100\n010001010101D51B0050500019400820\nB80080001000001EEC2C80A070381A40\n3020350040442100001E000000FC0050\n492D4B564D20566964656F0A000000FD\n00323D0F2E0F0000000000000000014D\n02030400DE0D20A03058122030203400\nF0B400000018E01500A0400016303020\n3400000000000018B41400A050D01120\n3020350080D810000018AB22A0A05084\n1A3030203600B00E1100001800000000\n00000000000000000000000000000000\n00000000000000000000000000000000\n00000000000000000000000000000045\n</code></pre> 1920x1080 as preferred. Useful for Gigabyte GA-H77-DS3H, Intel NUC or ASRock H670 PG Riptide <pre><code>00FFFFFFFFFFFF005262888800888888\n1C150103800000780AEE91A3544C9926\n0F505425400001000100010001000100\n010001010101D32C80A070381A403020\n350040442100001E7E1D00A050001940\n3020370080001000001E000000FC0050\n492D4B564D20566964656F0A000000FD\n00323D0F2E0F000000000000000001C4\n02030400DE0D20A03058122030203400\nF0B400000018E01500A0400016303020\n3400000000000018B41400A050D01120\n3020350080D810000018AB22A0A05084\n1A3030203600B00E1100001800000000\n00000000000000000000000000000000\n00000000000000000000000000000000\n00000000000000000000000000000045\n</code></pre> 1280x1024 as preferred, disabled 1080p at all. This may be necessary in extremely rare cases if the BIOS is completely buggy. In the future, we will provide a way to dynamically switch EDID <pre><code>00FFFFFFFFFFFF005262888800888888\n1C150103800000780AEE91A3544C9926\n0F50542FCF0001000100010001000100\n0100010101018C2300A050001E403020\n370080001000001E000000FC0050492D\n4B564D20566964656F0A000000FD0032\n3D0F2E0F000000000000000000000010\n0000000000000000000000000000016B\n02030400DE0D20A03058122030203400\nF0B400000018E01500A0400016303020\n3400000000000018B41400A050D01120\n3020350080D810000018AB22A0A05084\n1A3030203600B00E1100001800000000\n00000000000000000000000000000000\n00000000000000000000000000000000\n00000000000000000000000000000045\n</code></pre>"},{"location":"edid/#default-edid","title":"Default EDID","text":"<p>If for some reason you need to go back to the default EDID (changing attached device etc), you can find it locally on the Pi at <code>/usr/share/kvmd/configs.default/kvmd/edid</code> or in the kvmd repo.</p>"},{"location":"ezcoo/","title":"ezCoo managed multiport KVM switch","text":""},{"location":"ezcoo/#ezcoo-managed-multiport-kvm-switch","title":"ezCoo managed multiport KVM switch","text":"<p>The ezCoo managed switch can be controlled by PiKVM to allow it to connect to multiple hosts. A typical scenario is a single PiKVM device which can control and switch between multiple hosts or servers using the ezCoo switch. UI elements can be added to the GPIO dropdown to allow switching between hosts from the PiKVM webpage. The instructions here were tested with the ezCoo SW41HA HDMI 4x1 switch ezCoo EZ-SW41HA-KVMU3L 4x1 switch OR eccoo EZ-SW41HA-KVMU3P 4x1 switch. Both older USB2.0 and newer USB3.0 variants are supported. The following was testing on a Raspberry Pi 4 but should also work on the Pi 2 and 3. This document was createdy using the contributions from multiple users in our Discord and the author appreciates their efforts.</p> <p>Info</p> <p>While most images of the switch do not show the sides, there is a Micro USB port on the side of the ezCoo switch. This is the management port, which is controlled via COM port on the ezCoo KVM. When plugged into the Raspberry Pi, it appears as <code>/dev/ttyUSB0</code>.</p> <p>Info</p> <p>Audio was not tested, it is assumed to be non-functional.</p> <p>Tip</p> <p>ezCoo EZ-SW41HA-KVMU3L - includes 4x1m USB 3.0 A Male to A Male. You will need 1 extra USB A Male to USB Micro B to connect from the PiKVM to the ezcoo \"F/W CTL - Management\" port</p>"},{"location":"ezcoo/#connections","title":"Connections","text":"<p>EZCOO Wiring example can be found here Scroll down to bottom of page for picture</p> <p>Please review the item description and manual before deploying.</p> <p>From a high level, the ezCoo switch uses standard connections to the host machines (USB-A to USB-B and HDMI for USB2 version, USB-A to USB-A for the USB3 version). The Raspberry Pi OTG connector (the one coming from the USB-C port on a Pi 4 via the custom splitter cable or device) should be connected to the USB 3 port on the ezCoo switch. There is an additional USB cable connected to the managed port on the switch.</p> <ol> <li> <p>Connect the USB-C cable from the Raspberry Pi OTG port to ezCoo switch USB 3 port on the front or USB 1 port on the back of the switch. Note: If this cable is connected to the keyboard port (USB 2) of the ezCoo switch, the mouse will not be present.</p> </li> <li> <p>Connect the HDMI out from the ezCoo switch to the Raspberry Pi CSI-2 to HDMI input. Other users have reported HDMI encoder USB dongles as working.</p> </li> <li> <p>Connect a USB-A to Micro USB cable from the Raspberry Pi to the management port on the side of the ezCoo switch.</p> </li> <li> <p>Connect host USB and HDMI cables from the ezCoo switch to the machines to be managed per the switch instructions.</p> </li> <li> <p>At this point the KVM switch should be present as a device on the PiKVM. SSH into PiKVM and ensure a device like <code>/dev/ttyUSB0</code> is present. The following instructions assume this is the KVM switch.</p> </li> </ol> <p>Info</p> <p>There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi CSI2-HDMI encoder. These limitations apply equally when using the ezCoo KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the ezCoo switch before powering the hosts on.</p>"},{"location":"ezcoo/#adding-ui-elements-to-control-the-kvm-switch","title":"Adding UI elements to control the KVM switch","text":"<p>The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected.  The instructions below will make these available in the PiKVM UI after clicking the \"GPIO\" menu button in the KVM view.</p> <ol> <li> <p>Enable read-write mode on the SD card via <code>rw</code></p> </li> <li> <p>Edit the file: <code>nano /etc/kvmd/override.yaml</code> and include the following. Note the assumption that the KVM switch is present on <code>/dev/ttyUSB0</code>:</p> <pre><code>kvmd:\ngpio:\ndrivers:\nez:\ntype: ezcoo\nprotocol: 2\ndevice: /dev/ttyUSB0\nscheme:\nch0_led:\ndriver: ez\npin: 0\nmode: input\nch1_led:\ndriver: ez\npin: 1\nmode: input\nch2_led:\ndriver: ez\npin: 2\nmode: input\nch3_led:\ndriver: ez\npin: 3\nmode: input\nch0_button:\ndriver: ez\npin: 0\nmode: output\nswitch: false\nch1_button:\ndriver: ez\npin: 1\nmode: output\nswitch: false\nch2_button:\ndriver: ez\npin: 2\nmode: output\nswitch: false\nch3_button:\ndriver: ez\npin: 3\nmode: output\nswitch: false\nview:\ntable:\n- [\"#Input 1\", ch0_led, ch0_button]\n- [\"#Input 2\", ch1_led, ch1_button]\n- [\"#Input 3\", ch2_led, ch2_button]\n- [\"#Input 4\", ch3_led, ch3_button]\n</code></pre> Editing '#Input X' will change the table name in the GUI drop down, if you want a different name, name it something else and restart kvmd. <p>This now only applies to older images, newer images do not have this issue. Make sure to notate the spaces for each line, needs to be a total of 4 spaces added per line (NOT tabs):</p> <pre><code>For example:\n    parent: 0 spaces (kvmd:)\n    child: 4 spaces (gpio:)\n    sub-child: 8 spaces (drivers:)\n    sub-sub-child: 12 spaces (ez:)\n</code></pre> </li> <li> <p>Return to read-only mode for the sd card via <code>ro</code>.</p> </li> <li> <p>Restart the kvmd service: <code>systemctl restart kvmd</code>.</p> </li> <li> <p>If you are still not getting KB output, issue a <code>ls -la /dev/tty* | grep USB</code> , if no output change cables (Alot of cables are power only)</p> </li> </ol>"},{"location":"ezcoo/#switching-between-hosts-in-the-ui","title":"Switching between hosts in the UI","text":"<p>To switch between hosts, enter the KVM UI and click the \"GPIO\" menu.  You should see 4 inputs, one of which will have a green circle indicating it is currently selected.  Click the other inputs to change the selected host.</p>"},{"location":"ezcoo/#additional-step-for-the-usb-20-version-old-eol-version","title":"Additional step for the USB 2.0 version (Old EOL version)","text":"<p>Please remove <code>protocol: 2</code> to the override.yaml under the <code>type: ezcoo</code> at the same level:</p> <pre><code>kvmd:\ngpio:\ndrivers:\nez:\ntype: ezcoo\ndevice: /dev/ttyUSB0\n</code></pre>"},{"location":"ezcoo/#developer-info","title":"Developer info","text":"<ul> <li>The official protocol version 1 reference</li> <li> Differences between protocols 1 and 2 <pre><code>===============================================================================================================================\n=********************************************************Systems HELP*********************************************************=\n=-----------------------------------------------------------------------------------------------------------------------------=\n=                        System Address = 00           F/W Version : 1.20                                                     =\n=   Azz                           :  All Commands start by Prefix System Address zz, if [01-99]                               =\n=-----------------------------------------------------------------------------------------------------------------------------=\n=   EZH                           : Help                                                                                      =\n=   EZSTA                         : Show Global System Status                                                                 =\n=   EZS RST                       : Reset to Factory Defaults                                                                 =\n=   EZS ADDR xx                   : Set System Address to xx {xx=[00~99](00=Single)}                                          =\n=   EZS CAS EN/DIS                : Set Cascade Mode Enable/Disable                                                           =\n=   EZS OUTx VS INy               : Set Output x To Input y{x=[0~2](0=ALL), y=[1~4]}                                          =\n=   EZS IR SYS xx.yy              : Set IR Custom Code{xx=[00-FFH],yy=[00-FFH]}                                               =\n=   EZS IR OUTx INy CODE zz       : Set IR Data Code{x=[1~2],y=[1~4],zz=[00-FFH]}                                             =\n=   EZG ADDR                      : Get System Address                                                                        =\n=   EZG STA                       : Get System System Status                                                                  =\n=   EZG CAS                       : Get Cascade Mode Status                                                                   =\n=   EZG OUTx VS                   : Get Output x Video Route{x=[0~2](0=ALL)}                                                  =\n=   EZG IR SYS                    : Get IR Custom Code                                                                        =\n=   EZG IR OUTx INy CODE          : Get IR Data Code{x=[1~2],y=[1~4]}                                                         =\n=   EZS OUTx VIDEOy               : Set Output VIDEO Mode                                                                     =\n=                                   {x=[1~2], y=[1~2](1=BYPASS,2=4K-&gt;2K)}                                                     =\n=-----------------------------------------------------------------------------------------------------------------------------=\n=Input Setup Commands:(Note:input number(x)=HDMI(x),x=1)                                                                      =\n=   EZS INx EDID y                : Set Input x EDID{x=[0~4](0=ALL), y=[0~15]}                                                =\n=                                   0:EDID_BYPASS         1:1080P_2CH_HDR          2:1080P_6CH_HDR        3:1080P_8CH_HDR     =\n=                                   4:1080P_3D_2CH_HDR    5:1080P_3D_6CH_HDR   6:1080P_3D_8CH_HDR                             =\n=                                   7:4K30HZ_3D_2CH_HDR  8:4K30HZ_3D_6CH_HDR  9:4K30HZ_3D_8CH_HDR                             =\n=                                   10:4K60HzY420_3D_2CH_HDR  11:4K60HzY420_3D_6CH_HDR  12:4K60HzY420_3D_8CH_HDR              =\n=                                   13:4K60HZ_3D_2CH_HDR  14:4K60HZ_3D_6CH_HDR  15:4K60HZ_3D_8CH_HDR                          =\n=                                   16:H4K_DOLBY_VISION_ATMOS                                                                 =\n=   EZG INx EDID                  : Get Input x EDID  Index{x=[0~4](0=ALL)}                                                   =\n=-----------------------------------------------------------------------------------------------------------------------------=\n=*****************************************************************************************************************************=\n===============================================================================================================================\n</code></pre> </li> </ul>"},{"location":"ezcoo/#simple-troubleshooting-steps-to-perform","title":"Simple troubleshooting steps to perform","text":"<pre><code>    Video Issues:\n        Hook a monitor to the output and test\n        Reseat the cables\n        Change out the cables\n\n    Switching issues:\n        SSH or open a web terminal to your PiKVM\n        `ls -la /dev/ttyUSB*` - This should give you an output. If not, try a different cable till an output is displayed.\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq-troubleshooting","title":"FAQ &amp; Troubleshooting","text":"<p>As a first step, we recommend carefully reading our documentation on GitHub or the updated documentation. Most steps to successfully set up your PiKVM are already described there. If you run into any issues you can check this page which will list common errors. If that still doesn't help you you're welcome to raise an issue ticket or join our Discord for further help.</p>"},{"location":"faq/#common-questions","title":"Common questions","text":"Can I connect multiple servers to a single PiKVM? <p>Yes, but it requires additional work to set up. See this page.</p> How can I get the access to PiKVM in my local network over Internet? <p>You can use port forwarding for port 443 on your router if it has an external IP address. In all other cases, you can use the excellent free VPN service Tailscale, which can be configured on PiKVM with a few simple commands.</p> Can I assign a static IP to a PiKVM <p>Edit file <code>/etc/systemd/network/eth0.network</code> for Ethernet or <code>wlan0.network</code> for Wi-Fi and edit the <code>[Network]</code> section:</p> <pre><code>[Network]\nAddress=192.168.x.x/24\nGateway=192.168.x.x\nDNS=192.168.x.x\nDNS=192.168.x.x\n</code></pre> <p>If you're using Wi-Fi but you don't have <code>/etc/systemd/network/wlan0.network</code> file, then first you will need to <code>migrate the Wi-Fi settings from</code>netctl<code>to</code>systemd-networkd`.</p> Can I use PiKVM for gaming? <p>No, because:</p> <ul> <li>For HDMI-CSI bridge, bus bandwidth is not enough to transmit more than 1080p50.</li> <li>For HDMI-USB dongle, high latency and low video quality.</li> <li>General hardware video capture differs from software streaming and introduces additional latency.</li> </ul> Can PiKVM do 4K video? <ul> <li>For HDMI-CSI bridge, no. There is not enough bandwidth in the CSI bus for that much data. 1080p50 will max out the bandwidth.</li> <li>For the USB capture devices: technically yes, they will downsample to something smaller to meet the USB 2.0 bandwidth limitations, so the source may be 4k, but the stream will not.</li> <li>The 4K real-time video will not fit through the network anyway.</li> </ul> Where does the cursor/video latency come from? <p>Here is the chain of transferring an image to your browser or VNC client.</p> <p><code>Capture device -&gt; Compression -&gt; Network -&gt; Decompression -&gt; Rendering</code></p> <p>100-200ms is very, very fast for this. But we are working to speed things up even more.</p> Does PiKVM support sound? <p>Yes but the only officially supported version is the PiKVM V3+ devices, V2 we will attempt best effort but ultimatly we do not support CSI modules or USB.</p> Can I power the Pi via PoE? <p>Yes! But you still need to ensure you isolate the 5v connection between the Raspberry Pi and host PC to prevent backpower issues that can cause instability or damage to either the host PC or the Pi. Power/Data cable + USB power blocker would work.</p> Do I need a power splitter? Why do I need one? <ul> <li>Yes for RPi4 - Please see the main readme for splitter types listed under V2 hardware</li> <li>Yes for Zero W and Zero W 2, if using dedicated power you still need to split the power from the data towards the target. If using the target for power, this is not needed.</li> <li>This is not needed if you have a PiKVM V3, as the HAT splits power and signal on the board.</li> </ul> Can I use PiKVM with non-Raspberry Pi boards (Orange, Nano, etc)? <p>Yes, but you will have to prepare the operating system yourself. For the PiKVM software, you will need to replace some config files (such as UDEV rules). If you are a developer or an experienced system administrator, you will not have any problems with this. In addition, we are open to patches. If you need help with this, please contact us via Discord.</p> Is PiKVM OS its own custom distro? <p>No. PiKVM OS is an Arch Linux ARM with our own repository for KVM-related packages. We distribute OS images (that is, our Arch Linux ARM build) to simplify installation, since PiKVM requires some tuning of the OS and special partitioning of the memory card.</p> Why is PiKVM OS based on Arch Linux ARM and not Raspbian / Raspberry Pi OS? <p>There are several reasons:</p> <ul> <li>Several years ago, when PiKVM was just starting out, Raspbian didn't have a minimalistic image and the transition to systemd was in full swing, which is why the distribution was not too stable.</li> <li>Raspbian did not have all the necessary packages in the repositories to satisfy most software dependencies.</li> <li>PiKVM was born as a pet project, and the founder likes Arch the most.</li> </ul> <p>However, we plan to provide an alternative OS image based on Raspbian in the future - now it is quite stable.</p> Can I use an iPad on PiKVM? <ul> <li>Yes, with the correct hardware you can control an iPad.</li> <li>In the opposite sense - yes, use VNC and use JUMP app (fully-featured but more expensive), or bVNC (cheap). RealVNC does NOT work.</li> </ul> How do I add my own SSL cert? <p>If you have a certificate (making a cert falls outside the scope of PiKVM - please reference OpenSSL documentation or use Let's Encrypt), replace keys in <code>/etc/kvmd/nginx/ssl</code>, edit <code>/etc/kvmd/nginx/ssl.conf</code> if necessary and restart <code>kvmd-nginx</code> service.</p> How do I emulate various USB devices on the target machine? <p>Please review First Steps before continuing By default this is what is set:</p> <pre><code>otg:\nmanufacturer: PiKVM\nproduct: Composite KVM Device\nvendor_id: 0x1D6B\nproduct_id: 0x0104\nserial: CAFEBABE\n</code></pre> <p>You can change how this is displayed with the following example for <code>/etc/kvmd/override.yaml</code> file:</p> <pre><code>otg:\nmanufacturer: Corsair\nproduct: Corsair Gaming RGB\nvendor_id: 0x6940\nproduct_id: 0x6973\nserial:\n</code></pre> <p>Use the following USB database to get the desired devices: https://the-sz.com/products/usbid or https://devicehunt.com.</p> Can I run a desktop on PiKVM? <p>Yes, but it's strongly not recommended OR supported as this OS should be used in read-only mode and it will need read-write enabled all of the time. Instructions here.</p> How do I blank the oled screen? <p>Please run the following: </p><pre><code>/usr/bin/kvmd-oled --height=32 --interval=5 --clear-on-exit --text=\"turn off in 5s\"\nsystemctl disable --now kvmd-oled kvmd-oled-reboot kvmd-oled-shutdown\n</code></pre> How do I rotate the OLED display? <p>Please run the following: </p><pre><code>1. mkdir -p /etc/systemd/system/kvmd-oled.service.d\n2. Create file /etc/systemd/system/kvmd-oled.service.d/override.conf:\n[Service]\nExecStart=\nExecStart=/usr/bin/kvmd-oled --height=32 --clear-on-exit --rotate=2\n</code></pre> I am getting a 500/503 error when I try and access the main KVM page! <p>This maybe due to a few of the following:</p> <ul> <li>Missing <code>/etc/kvmd/override.yaml</code> file, to resolve it run <code>rw; touch /etc/kvmd/override.yaml; ro</code></li> <li>Bad YAML syntax, edit your <code>/etc/kvmd/override.yaml</code> file and undo what you did and restart PiKVM.</li> </ul> How can I use the serial console to access to access other devices <p>You need to stop the service which listens on the <code>/dev/ttyAMA0</code>:</p> <pre><code>rw\nsystemctl stop serial-getty@ttyAMA0.service\n</code></pre> <p>If you want this change permanent (not starting again after reboot), you can disable this service, ('enable' to reverse this decision):</p> <pre><code>systemctl disable serial-getty@ttyAMA0.service\n</code></pre> <p>Note</p> <ul> <li>Only USB OR the RJ-45 serial connector will work, you can't use them together! </li> <li>If you disable the service permanently, you can't recover your device via serial console if you need this.</li> <li>There are some reports, that you need to remove <code>ttyAMA0</code> from /boot/cmdline.txt, but this is not needed on new installations.</li> </ul> How can I have different hostnames for multiple pikvms? <p>Using a SSH session or the web terminal: - Make sure you're <code>root</code>, if you're not root use the <code>su</code> command to become root - Enter read write mode of the PiKVM by executing the <code>rw</code> command - Execute: <code>hostnamectl set-hostname yournewhostname.domain</code> - Optional: Edit <code>/etc/kvmd/meta.yaml</code> to alter the displayed server name in the web UI - Reboot the pikvm</p> Can I run PiKVM in a docker? <p>No, technically it might be possible but the OS requires many specific settings that cannot be performed inside the container.</p>"},{"location":"faq/#first-steps","title":"First steps","text":"I can't find the PiKVM IP address in my network <p>Follow this guide.</p> What is the default password? How do I change it? <p>There are two types of accounts: OS and PiKVM (web interface) accounts. The system account <code>root</code> can be used for SSH/UART access and has the password <code>root</code>. The web interface account is called <code>admin</code> and has the password <code>admin</code>, no 2FA code. The PiKVM account cannot be used for SSH access and vice versa.</p> <p>To change passwords, use the following commands (under root):</p> <pre><code>su -  # If you're in the webterm\nrw  # Switch filesystem to read-write mode\npasswd root  # Change OS root password\nkvmd-htpasswd set admin  # Change web ui admin password\nro  # Back to read-only\n</code></pre> <p>Optionally you can enable the two-factor authentication.</p> How do I add another user? <p>As stated above you need to make 2 accounts, 1 for the shell, the other for the PiKVM Web UI.</p> <p></p><pre><code>If you require additional users for PiKVM UI, you can use the following:\n# rw\n# su -\n# kvmd-htpasswd set &lt;user&gt; # Adds a new user\n# kvmd-htpasswd set &lt;user&gt; # Sets the password as long as the user exists\n# kvmd-htpasswd del &lt;user&gt; # Removes/deletes a user\n\nTo add a shell/terminal account:\n# rw\n# su -\n# adduser &lt;user&gt;\n# passwd &lt;user&gt;\n</code></pre> Keep in mind that the more users that are added, the stream if accessed, fps will drop.  How do I get root access in the web terminal? <p>The web terminal works with the account <code>kvmd-webterm</code>. This is a regular user with no administrator privileges. In addition, <code>sudo</code> and login are disabled for this user for security reasons. To get <code>root</code> access, you need to use the <code>su -</code> command (minus is important) and enter the root password.</p> Where is the PiKVM configuration located? <p>Almost all KVMD (the main daemon controlling PiKVM) configuration files are located in <code>/etc/kvmd</code>. You can also find nginx configs and SSL certificates there. KVMD configs use YAML syntax. The specific platform parameters can be found in the file <code>/etc/kvmd/main.yaml</code> and you should never edit it. Use <code>/etc/kvmd/override.yaml</code> to redefine the system parameters.</p> <p>Files that are not recommended for editing have read-only permissions. If you edit any of these files, you will need to manually make changes to them when you upgrade your system. You can view the current configuration and all available KVMD parameters using the command <code>kvmd -m</code>.</p> I can't edit any file on PiKVM. Why is the system in read-only mode? <p>The PiKVM file system is always mounted in read-only mode. This measure prevents it from being damaged by a sudden power outage. To change the configuration you must first switch the filesystem to write mode using the command <code>rw</code> from root. After the changes, be sure to run the command <code>ro</code> to switch it back to read-only. If you get a message that the file system is busy, then the easiest way is to perform a <code>reboot</code>.</p> I want to get read-write filesystem all of the time <p>DON'T DO THIS</p> <p>DON'T DO THIS</p> <p>DON'T DO THIS</p> <p>Seriously, DON'T. Read-only mode increases the life of the memory card and protects the filesystem from power loss failures. See the question above ^ ^ ^</p> <p>You can turn it off, but don't say you weren't warned.</p> DON'T OPEN THIS SPOILER AND DON'T DO THIS <p>Okay, fine.</p> <ul> <li>Edit <code>/boot/cmdline.txt</code> and change option <code>ro</code> to <code>rw</code>.</li> <li>Do the same in <code>/etc/fstab</code> for the <code>/boot</code> partition.</li> <li>Comment <code>tmpfs</code> lines in <code>/etc/fstab</code> for <code>/var/lib</code> and <code>/var/log</code>.</li> </ul> <p>But again: DON'T DO THIS</p> How to set the date, time and timezone from command line? <ul> <li>Become root with the command <code>su -</code> or <code>sudo -s</code>.</li> <li>Enable read/write with the command <code>rw</code>.</li> <li>Find your timezone string e.g. <code>timedatectl list-timezones</code> or <code>timedatectl list-timezones | grep -i australia</code>.</li> <li>Set the timezone with <code>timedatectl set-timezone &lt;YourTimeZoneHere&gt;</code> e.g. <code>timedatectl set-timezone Australia/Victoria</code>.</li> <li>Stop the time syncing service with <code>systemctl stop systemd-timesyncd</code> as this will prevent the next step if running.</li> <li>Set the time and date with <code>timedatectl set-time 'YYYY-MM-DD HH:MM:SS'</code> e.g. <code>timedatectl set-time '2023-02-26 14:50:10'</code>.</li> <li>If you have hardware clock e.g. V3+, update it with <code>hwclock --systohc</code> , then check it with <code>hwclock --show</code>.</li> <li>Switch filesystem to RO-mode with the command <code>ro</code>.</li> </ul> How do I install or remove packages in PiKVM OS? <p>PiKVM OS is based on Arch Linux ARM and uses the pacman package manager.</p> <ul> <li>Ensure the date is correct: <code>date</code>. Otherwise you may get the error <code>SSL certificate problem: certificate is not yet valid</code></li> <li>Switch filesystem to RW-mode: <code>rw</code>.</li> <li>Find some packages (<code>emacs</code> for example): <code>pacman -Ss emacs</code>.</li> <li>Install it, while keeping the system updated: <code>pacman -Syu emacs</code>.</li> <li>To only update packages without installing new ones, use <code>pacman -Syu</code></li> <li>Remove it: <code>pacman -R emacs</code>.</li> <li>Switch filesystem to RO-mode: <code>ro</code>.</li> </ul> How do I update PiKVM with the latest software? <p>This is ONLY recommended if you need a feature, otherwise this should ONLY be done if you are physically at the device and can reflash the sd card as a means of recovery. PiKVM OS is based on Arch Linux ARM and is fully updated from the repository by a regular package manager. Connect to your PiKVM via ssh and run:</p> <ul> <li>Ensure the date is correct: <code>date</code>. Otherwise you may get the error <code>SSL certificate problem: certificate is not yet valid</code></li> <li>Run the following:</li> </ul> <pre><code># date\n# rw\n# pacman -Syu\n# reboot # Allow 10 to 15 minutes for a response.\n</code></pre> <p>Pacman saves all installed packages in a compressed format so that you can roll back to the old version if something goes wrong. After you've updated and made sure everything works, (ONLY for older images, newer images has this partition expended and no longer has this issue) it makes sense to clear the package cache so that it doesn't take up space on the SD card: <code>rw; rm -rf /var/cache/pacman/pkg; ro</code>.</p> I don't need ATX functions. How do I disable this in the Web UI? <p>If you don't need ATX power control you can disable the relevant Web UI menu in <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>kvmd:\natx:\ntype: disabled\n</code></pre> <p>... then restart <code>kvmd</code>:</p> <pre><code># systemctl restart kvmd\n</code></pre> How do I disable the web terminal? <pre><code># systemctl disable --now kvmd-webterm\n</code></pre> How do I completely disable authorization in PiKVM? <p>Edit the file <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>kvmd:\nauth:\nenabled: false\n</code></pre> <p>... then restart <code>kvmd</code>:</p> <pre><code>[root@pikvm ~]# systemctl restart kvmd\n</code></pre> Can I have different hostnames for each of my PiKVMs? <p>Yes! And it's easy to do! Using a SSH session or the web terminal: * Make sure you are root, run <code>rw</code> then run <code>hostnamectl set-hostname yournewhostname.domain</code>. * Optional: edit <code>/etc/kvmd/meta.yaml</code> to alter the displayed hostname in the web UI. * Run <code>ro</code> and <code>reboot</code>.</p>"},{"location":"faq/#video-problems","title":"Video problems","text":"I can see the video but I can't see the WebRTC switch <p>WebRTC is an alternative mode for the default MJPEG and it's only supported on V2+ platforms with the CSI video capture device. See this page to solve any problems with WebRTC.</p> PiKVM does not show the video from the computer at all <ul> <li>Double-check that the video capture device is connected correctly. For the CSI bridge, this should be exactly the camera port; for the USB dongle, strictly the port indicated in the picture.</li> <li>Some laptops do not output any signal until you switch the output (usually via the FN + and an F5 key on the keyboard).</li> <li>Your computer may have turned on sleep mode for the monitor. Move the mouse to turn it off.</li> <li>For windows you might need to check for the active signal resolution. To change the active signal resolution you have to go to Settings&gt;System&gt;Display&gt;Advanced display settings&gt;Display adapter properties then, click \"List All Models\" and choose the one you want. Keep trying different Hz settings.</li> </ul> The video works in the booted OS, but not in the BIOS/UEFI <p>This problem appears on Intel NUC, GA-H77-DS3H, and some other devices when using a CSI bridge. All you need to do is change the EDID data. This is the information about supported resolutions that the CSI bridge reports to your computer.</p> Glitchy or wrong BIOS/UEFI resolution <p>On some motherboards, the BIOS may be displayed at a lower resolution, or with some rendering issues/glitches, specially on newer ASUS ones. Like this:</p> <p></p> <p>This can be solved by enabling the Compatibility Support Module (CSM) in your BIOS, usually under the Boot options.</p> <p>If you can't or don't want to enable the CSM, you can try connecting a DisplayPort (DP) monitor, or a dummy plug. If you remove the DP cable/adapter the bug will reappear.</p> <p>If none of this works, try connecting the DP cable first, boot into the BIOS, disable the CSM and shutdown (do not restart) your PC. Then, boot into the BIOS and enable the CSM before shutting down your PC. Then connect the HDMI and turn your PC on again.</p> There is no video in GRUB2, but there is before and after <p>Sometimes this can be caused by the specifics of the BIOS/UEFI and how GRUB2 works with video.</p> <p>This can be solved by enabling the Compatibility Support Module (CSM) in your BIOS, usually under the Boot options. The video mode will be located in the same section. Switch the Video mode from UEFI to Legacy.</p> Why does the CSI bridge does not work with official Raspberry Pi PoE HAT? <p>Details here. The reason is that the official HAT has a built-in fan controller that conflicts with the TC358743 chip of the bridge. The solution is to disable the fan control and connect the fan to the power line so that it works continuously. To turn off the controller you need to add the line <code>disable_poe_fan=1</code> to <code>/boot/config.txt</code>.</p> The video freezes a few seconds after the start, restarting the Web UI or VNC does not help <p>The story is here. Very very rarely, Raspberry Pi boards can have a hardware defect that causes some of the chip blocks to be unstable under normal power. The solution is to slightly increase the power supply, as you would when overclocking. Add <code>over_voltage=1</code> (or <code>over_voltage=2</code> if previous doesn't help) to <code>/boot/config.txt</code> and perform <code>reboot</code>.</p> <p>To make sure that you are facing this particular problem, first perform a diagnostic:</p> <ul> <li>Boot the PiKVM without the specified options.</li> <li>Open Web-UI and wait for freezing.</li> <li>Click <code>System -&gt; Reset Stream</code>.</li> <li>Click <code>System -&gt; Open log</code> and make sure that the log contains messages like <code>H264: Can't wait for the VCOS semaphore</code>.</li> <li>Make sure that the last message from ustreamer was <code>H264: Configuring MMAL encoder</code> (not counting messages about connecting and disconnecting stream clients).</li> </ul> No image from computer with Linux + Awesome WM <p>Sometimes Awesome WM on Linux can't recognize a video output change on a cable. That is, if the cable was first inserted into the monitor, and then you reconnected it to PiKVM - it may happen that you will not see the image. It seems that the problem is Awesome WM, since for example with KDE, it is not reproducable. If you turn on your workstation with PiKVM already connected, everything will work fine.</p> Windows shows limited Available Resolutions <p>This is due to a driver issue. A possible resolution can be found here.</p>"},{"location":"faq/#usb-problems-keyboard-mouse-mass-storage-etc","title":"USB problems (keyboard, mouse, mass storage, etc)","text":"My computer does not recognize USB of PiKVM V2+ at all <ul> <li>Make sure that you have used the correct USB cable with DATA lines to connect the OTG port for the Raspberry to the computer. You may have decided to use a USB hub instead of a Y-cable and it won't work. Use good cables and follow the instructions :)</li> <li>In rare cases, some very buggy BIOSes do not like HID and Mass Storage in one USB device. You can either disable Mass Storage, or use an Arduino HID to physically separate them.</li> </ul> BIOS/UEFI does not recognize USB of V2+, but computer does <p>If you are using a USB hub or USB PCI controller, this may not be handled by your BIOS. Try to use another USB port. Some ports may have a built-in hub on the motherboard and a buggy BIOS that can't handle it.</p> My keyboard works in BIOS/UEFI, but my mouse does not <p>The BIOS does not support absolute mouse mode, which is preferred by PiKVM. In this case, you can enable relative or dual positioning mode.</p> I can't wake up suspended computer on V2+ <p>This feature is experimental and requires manual activation. Perform a full system update, edit <code>/etc/kvmd/override.yaml</code>, and reboot. After that, you can use remote wakeup by pressing any keyboard key or mouse button.</p> <pre><code>otg:\nremote_wakeup: true\n</code></pre> <p>For V4, you don't need to add this option as it is enabled by default.</p> <p>If something doesn't work, please report about the problem here (preferred) or here.</p> My mass storage drive works (I can boot an image from PiKVM V2+), but my keyboard/mouse does not <p>In rare cases, some very buggy BIOSes does not like HID and Mass Storage in one USB device. You can either disable Mass Storage, or use an Arduino HID to physically separate them.</p> Buggy absolute mouse on Windows 98 as managed server <p>How to fix:</p> <ul> <li>V2+.</li> <li>Arduino HID.</li> </ul> The mouse does not work with NVR/DVR CCTV <p>Often these devices have a buggy USB driver that does not understand an absolute mouse and/or a mouse with horizontal scrolling. In this case, the following configuration for <code>/etc/kvmd/override.yaml</code> will help you:</p> <pre><code>kvmd:\nhid:\nmouse:\nabsolute: false\nhorizontal_wheel: false\nmouse_alt:\ndevice: \"\"\n</code></pre> <p>It will make the relative mouse without horizontal scrolling the only mice.</p> There's big mouse latency on another Raspberry Pi as managed server <p>Unusual case: RPi4 is used as a PiKVM to control RPi3. In this case, the mouse delay may be several seconds. To fix it, append <code>usbhid.mousepoll=0</code> to the boot line in <code>/boot/cmdline.txt</code> on the managed server (i.e. RPI3 in our case) and reboot it. Source.</p> What speed is the USB OTG port? <p>Per the official RPI documentation, this is a limitation of the SoC.  The OTG port is only USB2.0, so is limited to 455 Mbit/s.</p>"},{"location":"faq/#web-ui-problems","title":"Web UI problems","text":"Chrome reports a Certificate Issue when I try to access the PiKVM web interface <p>The latest versions of Chrome do not allow access to the page with a self signed certificate, so if you see the following screen when loading the PiKVM website:</p> <p></p> <p>You can proceed by typing <code>thisisunsafe</code> and Chrome will then load the page. Also see Let's Encrypt page.</p> Pressing ESC in full screen mode causes the PiKVM page to close <p>Your browser does not support keyboard lock. Right now (January 2022), only Chromium implements this, so it works on Chrome, Edge, and Opera.</p> I can't use the PiKVM web interface on iOS: the Web UI network indicator flashes yellow <p>Safari on iOS contains an old bug that prevents a web application from connecting over a web socket if you use a self-signed certificate on the server (the default for PiKVM). There are two solutions:</p> <ul> <li>Install a valid SSL certificate for PiKVM host to <code>/etc/kvmd/nginx/ssl</code>.</li> <li>Disable HTTPS at all in <code>/etc/kvmd/nginx/nginx.conf</code>. To do this, comment some lines like in this file and restart web server: <code>systemctl restart kvmd-nginx</code>.</li> </ul> <p>Danger</p> <p>Don't do this for insecure networks or the Internet. Your passwords and what you type on the keyboard will be transmitted in unencrypted form.</p> The Web UI doesn't work properly in Firefox while it works fine in Chrome <p>This might be related to your specific hardware combination or browser hardware acceleration. Try disabling hardware acceleration in Firefox or updating your GPU and chipset drivers.</p> Unexpected interruption while loading the image for Mass storage drive <p>If problems occur when uploading even a small disk image it may be due to unstable network operation or antivirus software. It is well known that Kaspersky antivirus cuts off PiKVM connections during uploading, so you should add the PiKVM website to Kaspersky's list of exceptions or not filter web requests with the antivirus. Antivirus programs can also affect the performance of certain interface elements, for example the quality slider. For Kaspersky, the steps to add the network address of PiKVM's website to the exclusion list is: <code>Protection -&gt; Private browsing -&gt; Categories and exclusions -&gt; Exclusions</code>.</p> I can't click on anything when using the WebGUI on my phone <p>At this time, iOS has the buttons on the bottom if you have the correct resolution, sometimes you cannot see them due to the resolution. At this time, android is not supported, our suggestion is to use a VNC client.</p> I changed the Display Resolution to 720p but Windows still shows 1080p and the display looks blurry <p>This is mostly seen on Windows, open <code>Display Settings -&gt; Advanced display settings -&gt; Display adapter setting for Display 1 -&gt; List all modes -&gt; (Toggle between 720p30hz back to 50hz)</code>, this may need to be done if you need to change it back for 1080p.</p>"},{"location":"faq/#hardware-problems-wi-fi-atx-etc","title":"Hardware problems (Wi-Fi, ATX, etc)","text":"I can't connect to Wi-Fi on a Raspberry Pi Zero W <ul> <li>Some Zeros contain a defective Wi-Fi chip. You can either return the device to the store, or try the software workaround.</li> </ul> I can't connect to Wi-Fi at all! <ul> <li>If your device is unable to connect to the Wi-Fi network that you have set up, check the 2.4 GHz Wi-Fi channel used by your Wi-Fi access point.    If channels 12 to 14 are used (some countries have banned these channels) try to use a channel between 1 and 11.</li> </ul> LEDs/Switches do not work in ATX control <p>Double check your wiring as per the documentation. Make sure you placed the relays (G3VM-61A1) in the correct orientation. The relays for switches (Power, Reset) have a different orientation than the ones for LEDs.</p> My PiKVM keeps disconnecting from the Wi-Fi network <p>Try to edit <code>/etc/conf.d/wireless-regdom</code> and look for your region and uncomment it. For example: <code>WIRELESS_REGDOM=\"US\"</code>.</p> PiKVM complains about low power warnings <ul> <li>Are you using a \"proper\" power supply? Not one you hacked together?</li> <li>Some USB power bricks advertise 5V 2.1A or higher, but can't deliver consistent 5V.  Best to use Raspberry Pi Foundation recommended power supplies.</li> </ul> PiKVM complains about a RTC low voltage detected, date/time is not reliable <ul> <li>This is mearly a warning that can be ignored however, the following resolves the issue: </li> <li>Leave plugged in for 24+ hours and or</li> <li>Connect to the internet using the eth cable, the internal NTP service will set the time accordlingly</li> <li>Force a time sync: <code>rw &amp;&amp; hwclock --systohc\"</code> or <code>\"rw &amp;&amp; hwclock -w\"</code></li> <li>Set date and time manually can be found here.</li> </ul>"},{"location":"first_steps/","title":"First steps","text":""},{"location":"first_steps/#first-steps","title":"First steps","text":""},{"location":"first_steps/#first-power-on","title":"First power on","text":"<p>Warning</p> <ul> <li>V2 DIY owners: Please follow this first</li> <li>V3 HAT or pre-assembled users: Please follow this first</li> <li>For both to work and display a video, your target system needs to be configured for the following:     1920x1080p50Hz (In some rare instances, try 30hz)     1600x1200p60Hz     1280x720p60Hz</li> </ul> Optional setting up Wi-Fi <p>Please read the following caveats</p> <ol> <li>There is nothing more reliable than wired Ethernet, so it's better to use the cable. But who are we to stop you... :)</li> <li>Adding FIRSTBOOT=1 or FIRSTBOOT-1 will erase the msd partition, if used afterwords as a means of switching wifi networks, do not include this option. Instead, use different supplicant files for each wifi SSID, mv files to the supplicant dir as needed and reboot.</li> <li><code>pikvm.txt</code> will be removed once its been used. You will need to recreate it again if you did not provide the correct info</li> </ol> <p>If you want to connect PiKVM to a Wi-Fi network, you need to tell the device ESSID and password before first boot. To do this, mount the first partition of the memory card (FAT32) and edit or make the <code>pikvm.txt</code> file there. Do not remove line <code>FIRSTBOOT=1</code> or <code>FIRST_BOOT-1</code> for first time booting, just add your wifi settings like this:</p> <pre><code>FIRSTBOOT=1\nWIFI_ESSID='mynet'\nWIFI_PASSWD='p@s$$w0rd'\n</code></pre> <p>There is a possibility that, in countries that support CH13, the device will not connect. You will need to configure your router to disable channels 12-14 or disable Auto scan mode so it will connect.</p> <p>Save, unmount and follow the next step.</p> <p>Power up the device.</p> <p>Do not turn off the device until it's fully booted for the first time</p> <p>After turning on the power, PiKVM OS will generate unique SSH keys and certificates and will perform all necessary operations on the memory card.</p>"},{"location":"first_steps/#getting-access-to-pikvm","title":"Getting access to PiKVM","text":"<p>By default, PiKVM receives a dynamic IP address via DHCP. V3+ devices show IP on the built-in display. If you don't have a display, use the tips below:</p> Finding PiKVM in the network <p>To determine the IP address of your PiKVM, use one of the following methods:</p> <ul> <li>Common way: Open the web interface of your router and find the list of issued IP addresses there. It depends on the router model.</li> <li>Linux-only: Use command <code>arp-scan --localnet</code>.</li> <li>Linux, MacOS, Windows: Download and run Angry IP Scanner.</li> <li>Windows PowerShell: Use command <code>arp -a</code>.</li> </ul> <p>In order to find your RaspberryPi using the arp commands, you need to look for the following MAC Address's: B827EB, DCA632 or E45F01</p> <p>For future examples, let's assume that your PiKVM has received the address 192.168.0.100, which you have successfully detected using the instructions above. Then your device was assigned a hostname: pikvm.</p> Access to PiKVM Web Interface <p>In most networks you should be able to reach PiKVM via any browser with the URL <code>https://192.168.0.100/</code> OR <code>https://pikvm/</code>. Google Chrome (Chromium), Firefox and Safari work best with 0 extensions enabled, if one works but the other does not, this might be a browser/extension issue. Its advised you use private window or incognito mode. Internet Explorer and the pre-Chromium version of Microsoft Edge are not supported.</p> <p>The default user is <code>admin</code>, the password is also <code>admin</code>, and no 2FA code. After logging in, you will get access to the menu with the main functions. Using the Web Terminal, you can change system settings and passwords.</p> <p>The latest versions of Chrome on Mac OS do not allow access to the page with a self-signed certificate, which is used in PiKVM by default. You can proceed by typing <code>thisisunsafe</code> and Chrome will then load the page.</p> Access to PiKVM via SSH <p>SSH is the most common remote access method in the Linux world. PiKVM is accessible via SSH. This method is used to manage the device:</p> <ul> <li>Linux, MacOS: Open any terminal application and run: <code>ssh root@192.168.0.100</code> or <code>ssh root@pikvm</code>.</li> <li>Windows: Use PuTTY for this.</li> </ul> <p>The default <code>root</code> password is <code>root</code>.</p> OPTIONAL: Update PiKVM software <p>This part is not nessessary for a working OOB experience and should only be performed if you are physically at the PiKVM to recover it, you however, may benifit from performing the below actions. These are the instructions:</p> <pre><code>rw\npacman -Syu\nreboot\n</code></pre> \u272e \u272e \u272e CHANGE THE PASSWORDS! \u272e \u272e \u272e <p>PiKVM comes with the following default passwords:</p> <ul> <li>Linux admin (SSH, etc.): user <code>root</code>, password <code>root</code>.</li> <li>PiKVM Web Interface: user <code>admin</code>, password <code>admin</code>, no 2FA code.</li> </ul> <p>These are two separate entities with independent accounts. To change passwords, you will need to use the terminal (read below) access via SSH or Web Terminal. If you are using the Web Terminal, use the <code>su -</code> command to get root access (enter the root user password).</p> <p></p><pre><code># rw\n# passwd root\n# kvmd-htpasswd set admin\n# ro\n</code></pre> If you require additional user for the Web UI access, use the following: <pre><code># kvmd-htpasswd set &lt;user&gt; # Sets a new user with password\n# kvmd-htpasswd del &lt;user&gt; # Removes/deletes a user\n</code></pre> <p>Optionally you can enable the two-factor authentication.</p>"},{"location":"first_steps/#configuring-pikvm","title":"Configuring PiKVM","text":"<p>Most of the PiKVM settings are done through configuration files. All configuration changes must be made from under the <code>root</code> user (= the administrator).</p> <p>Obtaining root access</p> <ul> <li>If you have logged in via SSH, then most likely you are already <code>root</code>.</li> <li>To get <code>root</code> in the Web Terminal, use command <code>su -</code> and enter the root password.</li> </ul> <p>The PiKVM memory card is mounted in read-only mode. It protects the filesystem from damage in case of sudden power outage. To edit any files and make changes, it is necessary to remount the file system to the read-write mode.</p> <p>Enabling write mode</p> <ul> <li>To enable write-mode, run command <code>rw</code> (under <code>root</code>).</li> <li>To disable it, run command <code>ro</code>.</li> <li>If you receive the message \"Device is busy\", perform <code>reboot</code>.</li> </ul> <p>In this handbook, you will often find instructions for editing configuration files. The simplest and most beginner-friendly text editor is <code>nano</code>, but you can also use <code>vim</code>.</p> Editing files in the Web Terminal <pre><code>$ su -\n# rw\n# nano /etc/kvmd/override.yaml\n# ro\n</code></pre>"},{"location":"first_steps/#structure-of-configuration-files","title":"Structure of configuration files","text":"<p>Most of the PiKVM configuration files are located in the <code>/etc/kvmd</code> directory.</p> <p>The <code>/etc/kvmd/main.yaml</code> file defines the platform config and you should never edit it. To redefine system parameters use the file <code>/etc/kvmd/override.yaml</code>. All other files that are also not recommended for editing have read-only permissions.</p> <p>In the <code>/etc/kvmd/meta.yaml</code> file you can specify some information regarding the host that this PiKVM manages.</p> <p>Tip</p> <p>A complete list of all parameters can be viewed using the <code>kvmd -m</code> command.</p> <p>Files with the suffix <code>*.yaml</code> uses the YAML syntax and describes a parameter tree with key-value pairs of different types. To define the parameters within one section, an indent of 4 spaces is used. Comments starts with the <code>#</code> symbol.</p> <p>Only 4 spaces should be used for indentation</p> <p>Be careful when editing YAML and follow this rule. Invalid indentation or tabs instead of spaces will cause an error when starting the services.</p> Sections under the same keys should be merged <ul> <li> <p>Wrong:</p> <pre><code>kvmd:\ngpio:\ndrivers: ...\nkvmd:\ngpio:\nscheme: ...\n</code></pre> </li> <li> <p>Correct:</p> <pre><code>kvmd:\ngpio:\ndrivers: ...\nscheme: ...\n</code></pre> </li> </ul>"},{"location":"first_steps/#whats-next","title":"What's next?","text":"<ul> <li>Set up Internet access using port forwarding or Tailscale VPN.</li> <li>Explore PiKVM features using the table of contents on the left.</li> <li>Join our Discord to contact the community and developers.</li> <li>Check out the GitHub - PiKVM is a fully Open Source project!</li> </ul>"},{"location":"first_steps/#faq-and-troubleshooting","title":"FAQ and Troubleshooting","text":"<p>If you have any questions or run into problems, take a look at the FAQ. Seriously, it's really useful! We've probably already found a solution for it :)</p> <p>For any other help and support, you can contact us via the Discord chat.</p>"},{"location":"flashing_hid/","title":"Flashing the Arduino HID","text":""},{"location":"flashing_hid/#flashing-the-arduino-hid","title":"Flashing the Arduino HID","text":""},{"location":"flashing_hid/#serial-firmware-the-default-option","title":"Serial Firmware (the default option)","text":"<p>This operation can be done using your RPi (except Pi Zero W). Here the common steps:</p> <ol> <li> <p>Disconnect the RESET wire from the Arduino board.</p> </li> <li> <p>Connect the Arduino and RPi with a suitable USB cable.</p> </li> <li> <p>Log in to the Raspberry Pi using SSH.</p> </li> <li> <p>Upload the firmware (USB keyboard &amp; mouse is used by default, on this step you can choose PS/2 keyboard):</p> <pre><code># rw\n# systemctl stop kvmd\n# cp -r /usr/share/kvmd/hid ~\n# cd ~/hid\n# make\n# make install\n# reboot\n</code></pre> </li> <li> <p>Connect the RESET wire, disconnect the USB cable, and reboot the RPi.</p> </li> </ol> <p>With a Pi Zero W, you may consider building the firmware on a faster system and programming using USB or booting from another SD card and following the build steps using a clone of the KVMD repo.</p>"},{"location":"flashing_hid/#spi-firmware","title":"SPI Firmware","text":"<p>This operation can be done using your Raspberry Pi without disconnecting any wires:</p> <ol> <li> <p>Connect the Arduino and RPi with a suitable USB cable.</p> </li> <li> <p>Log in to the Raspberry Pi using SSH.</p> </li> <li> <p>Execute <code>rw</code>, add line <code>dtoverlay=spi0-1cs</code> to <code>/boot/config.txt</code> and perform <code>reboot</code>.</p> </li> <li> <p>Build and upload the firmware (USB keyboard &amp; mouse is used by default)</p> <pre><code># rw\n# systemctl stop kvmd\n# cp -r /usr/share/kvmd/hid ~\n# cd ~/hid\n# make spi\n# make install\n# reboot\n</code></pre> </li> </ol>"},{"location":"flashing_hid/#common-errors","title":"Common Errors","text":""},{"location":"flashing_hid/#circuit-issues","title":"Circuit Issues","text":""},{"location":"flashing_hid/#common-reset-wire","title":"Common - Reset Wire","text":"<p>Different pins are used for the reset wire but serve a similar function. For programming the TTL firmware over USB, the reset wire should be disconnected. When programming using SPI, the reset wire needs to be connected through a transistor circuit and connected to GPIO25 (pin 22 on the GPIO header)</p>"},{"location":"flashing_hid/#spi-specific-wiring","title":"SPI-specific Wiring","text":"<p>The 3v3, ground, Reset (GPIO25), MISO, MOSI, SCLK, and CS1 need to be connected appropriately. SPIO_CS0 and SPIO_CS1 can both be used but the default configuration uses SPIO_CS1 for the Arduino Microcontroller (CS0 is used for another device on the V3). These generally follow a block as follows:</p> <pre><code>Pin  0        2         4\n      2        0         0\n      .........GR.C.......\nRow # 12345678901234567890\n      ........3MMS........\nPin   0       1          3\n       1       7          9\n</code></pre> <p>The most common error is an \"off-by-one\" error where pins are shifted by a row. Some cases have non-standard GPIO layouts so please be careful when following these instructions using a case that has a modified pinout.</p>"},{"location":"flashing_os/","title":"Flashing the OS image","text":""},{"location":"flashing_os/#flashing-the-os-image","title":"Flashing the OS image","text":"<p>Micro-SD Card Requirements</p> <ul> <li>Minimum 16 Gb</li> <li>Class 10 is strongly recommended</li> </ul>"},{"location":"flashing_os/#download-the-image","title":"Download the image","text":"<p>Download the appropriate SD card image. Select it based on the board, platform, and the video capture device you are using:</p> <ul> <li>PiKVM V4<ul> <li>PiKVM V4 Mini - sha1</li> <li>PiKVM V4 Plus - sha1</li> </ul> </li> <li>PiKVM V3<ul> <li>PiKVM V3 HAT BOX Image (Raspberry Pi 4) OLED/FAN preactivated - sha1</li> <li>PiKVM V3 HAT DIY Assembly (Raspberry Pi 4) - sha1</li> </ul> </li> <li>DIY - Raspberry Pi 4, V2 platform:<ul> <li>For HDMI-CSI bridge - sha1</li> <li>For HDMI-USB dongle - sha1</li> </ul> </li> <li>DIY - Raspberry Pi Zero 2 W, V2 platform:<ul> <li>For HDMI-CSI bridge - sha1</li> </ul> </li> <li>DIY - Raspberry Pi Zero W (legacy), V2 platform:<ul> <li>For HDMI-CSI bridge - sha1</li> </ul> </li> </ul> <p>Pre-compiled images are only available for the Raspberry Pi 4 and Zero (2) W. For all other cases, you will need to build the operating system yourself. But don't worry, it's very simple.</p>"},{"location":"flashing_os/#flash-the-image","title":"Flash the image","text":"<p>Tip</p> <p>Ignore request to format your sd card, this step is not nessessary. Choose the most suitable method for you</p>"},{"location":"flashing_os/#using-linux-cli","title":"Using Linux CLI","text":"<p>Decompress and flash the image. Be careful when choosing the device path, it may be different on your OS:</p> <pre><code># xz --decompress v2-hdmi-rpi4-latest.img.xz\n# dd if=v2-hdmi-rpi4-latest.img of=/dev/mmcblkX\n</code></pre> <p>You can also use <code>dd_rescue</code> or <code>ddrescue</code>.</p> <p>Check the advanced settings (CTRL+SHIFT+X), make sure they are blank or the flash will fail</p>"},{"location":"flashing_os/#using-rpi-imager-linux-macos-and-windows","title":"Using RPi Imager (Linux, MacOS and Windows)","text":"<ol> <li> <p>Download and install the latest version of RPi Imager.</p> </li> <li> <p>Run RPi Imager:</p> <p></p> </li> <li> <p>Press CHOOSE OS and select Use custom image at bottom of the list:</p> <p></p> </li> <li> <p>After clicking on this item, select the image file (<code>.img.xz</code>), then click CHOOSE STORAGE:</p> <p></p> </li> <li> <p>Insert the memory card into the card reader. Choose the card reader from this list. Be careful and choose the right device:</p> <p></p> </li> <li> <p>After choosing the memory card, press the WRITE button. Confirm the operation when you are asked about it:</p> <p></p> </li> <li> <p>Wait for the process to finish. Get yourself a coffee or do some stretching :)</p> <p>Tip</p> <p>The process may hang at 99% for a long time, this is okay, just wait for it to complete</p> <p></p> </li> <li> <p>Remove the memory card after successful completion:</p> <p></p> <p>Tip</p> <p>If an error occurs during flashing or booting PiKVM, repeat the process.</p> </li> </ol> <p>If you encounter errors after flashing, reflash or use a different SD card.</p> <p>When you have completed these steps, please move to the First Steps doc.</p>"},{"location":"gpio/","title":"GPIO (pins, relays, lamps, etc)","text":""},{"location":"gpio/#gpio","title":"GPIO","text":"<p>GPIO (general-purpose input/output) is a series of digital interfaces that can be used to connect relays, LEDs, sensors, and other components.</p> <p>Warning</p> <ul> <li>Before using GPIO on PiKVM v3 HAT, carefully study the purpose of its ports.</li> <li>Using GPIO on a PiKVM was designed as a feature for advanced users, so please familiarize yourself with the topic to make sure you understand how to use use it before setting it up.</li> <li>Careless usage of GPIO can damage your Raspberry Pi or components.</li> </ul> <p>When talking about PiKVM and GPIO it refers not solely to the physical interface of the Raspberry Pi, but also to various plugins (for example, for USB relays) that can also be used transparently by emulating an abstract GPIO API.</p>"},{"location":"gpio/#basics","title":"Basics","text":"<p>Setting up GPIO is considerably complex. The interface is divided into several layers for flexibility. Any configuration is performed using a file <code>/etc/kvmd/override.yaml</code> which uses the YAML syntax. We will look at each part of the configuration individually with an example for each. Sections should be combined under shared keys.</p> <ul> <li> <p>Wrong:</p> <pre><code>kvmd:\ngpio:\ndrivers: ...\nkvmd:\ngpio:\nscheme: ...\n</code></pre> </li> <li> <p>Correct:</p> <pre><code>kvmd:\ngpio:\ndrivers: ...\nscheme: ...\n</code></pre> </li> </ul>"},{"location":"gpio/#drivers","title":"Drivers","text":"<p>The first part of the configuration refers to the hardware layer, which defines which IO channels are used (standard GPIO pins of the Raspberry Pi, an USB relay, and so on). If you just want to use GPIO with the default settings you can skip to the next section Scheme.</p> <p>Each hardware input/output requires a individual driver configuration entry. Each driver has a type (which refers to the plugin that handles the communication between PiKVM and the hardware) and a unique name. This allows you to either can add multiple drivers of the same type with different settings or connect multiple USB HID relays.</p> <p>Note</p> <p>Each driver requires a unique name. Names surrounded by double underscore are system reserved and should not be used.</p> <p>The only exception to this is the default GPIO driver with the name <code>__gpio__</code>, representing the physical GPIO interface of the Raspberry Pi. The configuration section for <code>__gpio__</code> is only required in your <code>/etc/kvmd/override.yaml</code> if you want to change the default settings. It can be omitted if you are fine with the defaults.</p> <pre><code>kvmd:\ngpio:\ndrivers:\n# This example shows how the default __gpio__ driver settings can be changed. It can be omitted if you are fine with the defaults.\n__gpio__:  # Names surrounded by double underscore are system reserved\ntype: gpio  # Refers to the plugin name handling the communication\n\n# You can define another gpio driver for some reason\nmy_gpio: type: gpio\n\n# Example for a USB HID relay connected to PiKVM\nrelay:\ntype: hidrelay\ndevice: /dev/hidraw0  # The path to the linux device\n</code></pre>"},{"location":"gpio/#scheme","title":"Scheme","text":"<p>The second part defines how the various driver channels are configured. Each channel has a unique name, a mode (<code>input</code> or <code>output</code>), a pin number, and a reference to the driver configured in the previous part.</p> <p>Note</p> <p>Names that starts and ends with two underscores (like <code>__magic__</code>) are reserved.</p> <p>Two interaction modes are available for outputs: <code>pulse</code> and <code>switch</code>. In pulse mode, the output quickly switches its state to logical 1 and back (just like pressing a button). In switch mode, it saves (toggles) the state that the user set. When PiKVM is started/rebooted (any time the KVMD daemon is started or stopped) all output channels are reset to 0. This can be changed using the <code>initial</code> parameter. For example, <code>initial=true</code> for logic 1 on startup.</p> <p>If you don't specify a driver for the channel in the scheme the default driver, <code>__gpio__</code> will be used.</p> Parameter Type Allowed values Default Description <code>led1</code>, <code>button1</code>, <code>relay1</code>, etc. <code>string</code> <code>a-Z</code>, numbers, <code>_</code>, <code>-</code> A section for the named channel <code>pin</code> <code>integer</code> <code>X &gt;= 0</code> Refers to a GPIO pin or driver's pin/port <code>mode</code> <code>enum</code> <code>input</code> or <code>output</code> Defines if a channel is used for input or output, may be limited by driver plugin Input only <code>debounce</code> <code>float</code> <code>x &gt;= 0</code> <code>0.1</code> Debounce time in seconds. <code>0</code> for disable debounce Output only <code>switch</code> <code>bool</code> <code>true</code> or <code>false</code> <code>true</code> Enables or disables the switch mode on the channel (enabled by default). <code>initial</code> <code>nullable bool</code> <code>true</code>, <code>false</code> or <code>null</code> <code>false</code> Defines the initial state of the switch upon boot, <code>null</code> for don't make changes (the last one does not supported by generic GPIO) <code>inverted</code> <code>bool</code> <code>true</code> or <code>false</code> <code>false</code> Inverts the active logical level <code>pulse</code> A section header to define switch pulse configuration <code>delay</code> <code>float</code> <code>X &gt;= 0</code> <code>0.1</code> Defines the pulse time in seconds, <code>0</code> for disable pulsing <code>min_delay</code> <code>float</code> <code>X &gt;= 0.1</code> <code>0.1</code> <code>max_delay</code> <code>float</code> <code>X &gt;= 0.1</code> <code>0.1</code> <pre><code>kvmd:\ngpio:\nscheme:\n# A certain device sends signals to the RPi and we want the PiKVM to display this as an led\nled1:\npin: 19 # GPIO pin number on the RPi\nmode: input led2:\npin: 16\nmode: input # Two outputs of RPi's GPIO\nbutton1:\npin: 26 # GPIO pin number on the RPi\nmode: output\nswitch: false  # Disable switching, only pulse available\nbutton2:\npin: 20\nmode: output\nswitch: false\n\nrelay1:  # Channel 1 of the relay /dev/hidraw0\npin: 0  # Numerating starts from 0\nmode: output  # Relays can't be inputs\ninitial: null  # Don't reset the state to 0 when initializing and terminating KVMD\nrelay2:  # Channel 2\npin: 1\nmode: output\ninitial: null\npulse:\ndelay: 2  # Default pulse value\nmax_delay: 2  # The pulse interval can be between min_delay=0.1 (by default) and max_delay=2\n</code></pre>"},{"location":"gpio/#view","title":"View","text":"<p>This is the last part of the required configuration. It defines how the previous driver and channel configuration is rendered on the Web interface. Here's an example for the example configuration above:</p> <pre><code>kvmd:\ngpio:\nview:\nheader:\ntitle: Switches  # The menu title\ntable:  # The menu items are rendered in the form of a table of text labels and controls\n- [\"#Generic GPIO leds\"]  # Text starting with the sharp symbol will be a label\n- []  # creates a horizontal separator and starts a new table\n- [\"#Test 1:\", led1, button1]  # Text label, one input, one button with text \"Click\"\n- [\"#Test 2:\", led2, button2]\n- []\n- [\"#HID Relays /dev/hidraw0\"]\n- []\n- [\"#Relay #1:\", \"relay1|Boop 0.1\"]  # Text label and button with alternative text\n- [\"#Relay #2:\", \"relay2|Boop 2.0\"]\n</code></pre> <p>This will be rendered as:</p> <p></p> <p>Some rules and customization options:</p> <ul> <li>Text starting with the <code>#</code> symbol will be a label.</li> <li>To place a channel in a cell, use the name you defined in the scheme.</li> <li>Inputs are displayed as round LEDs.</li> <li>Outputs are displayed as a switch AND a button.</li> <li>If the switch mode is disabled, only a button will be displayed. If pulse is disabled, only a switch will be shown.</li> <li>To change the LED's color specify it after the channel name like <code>\"led1|red\"</code>. Available: <code>green</code>, <code>yellow</code> and <code>red</code>.</li> <li>To change title of the button, write some its name like <code>\"relay1|My cool relay\"</code>.</li> <li>Buttons and switches can request confirmation on acting. To do this write its name like <code>\"relay1|confirm|My cool relay\"</code>. The third argument with a title is required in this case.</li> </ul> <p>Also you can place some leds in the menu title using the similar syntax:</p> <pre><code>kvmd\ngpio:\nview:\nheader:\ntitle: [\"#Test1:\", led1, \"Test2:\", led2]\n</code></pre>"},{"location":"gpio/#hardware-modules-and-pseudo-drivers","title":"Hardware modules and pseudo-drivers","text":""},{"location":"gpio/#raspberrys-gpio","title":"Raspberry's GPIO","text":"Click to view <p>The driver <code>gpio</code> provides access to regular GPIO pins with input and output modes. It uses <code>/dev/gpiochip0</code> and the libgpiod library to communicate with the hardware. Does not support saving state between KVMD restarts (meaning <code>initial=null</code>).</p> <p>You can use the interactive scheme when selecting the pins to use. Please note that when selecting a pin for a channel, you need to use a logical number instead of a physical number. That is, if you want to use a physical pin with the number 40, the channel must have the number 21 corresponding to the logical GPIO21.</p> <p>Channels should not use duplicate pins. You can also not use already used pins. To see which pins are currently used, run the command <code>gpioinfo</code>.</p>"},{"location":"gpio/#usb-hid-relay","title":"USB HID Relay","text":"Click to view <p>The driver <code>hidrelay</code> provides access to cheap managed USB HID relays that can be found on AliExpress. This driver does not support input mode, only output. To use it, you need to specify the path to the device file (like <code>/dev/hidraw0</code>) using the <code>device</code> parameter.</p> <p>Additionally, we recommend to configure access rights and static device name using UDEV rules. For example, create <code>/etc/udev/rules.d/99-kvmd-extra.rules</code>:</p> <pre><code>KERNEL==\"hidraw[0-9]*\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"16c0\", ATTRS{idProduct}==\"05df\", GROUP=\"kvmd\"\n</code></pre> <p>Channels should not use duplicate physical numbers. The driver supports saving state between KVMD restarts (meaning <code>initial=null</code>).</p>"},{"location":"gpio/#ezcoo-kvm-switch","title":"ezCoo KVM switch","text":"Click to view <p>You can use GPIO to control KVM port switching. This usually requires the use of relays and buttons, but for the ezCoo switch there is a special <code>ezcoo</code> driver that simulates GPIO by sending commands to the switch via serial port. So you can make a menu in PiKVM to control the multiport switch.</p>"},{"location":"gpio/#ipmi","title":"IPMI","text":"Click to view <p>The driver <code>ipmi</code> provides the ability to send IPMI commands (on, off, reset) and show the power status of the remote host. In fact, this is not a hardware driver, but something like a pseudo-GPIO. Each \"pin\" is actually responsible for a specific IPMI operation of <code>ipmitool</code>:</p> Pin Type Command <code>0</code> <code>input</code> <code>ipmitool ... power status</code>, can be used to draw the LED in the menu <code>1</code> <code>output</code> <code>ipmitool ... power on</code>, sends the <code>on</code> command (and only this), so like all other outputs it should be a button <code>2</code> <code>output</code> <code>ipmitool ... power off</code> <code>3</code> <code>output</code> <code>ipmitool ... power cycle</code> <code>4</code> <code>output</code> <code>ipmitool ... power reset</code> <code>5</code> <code>output</code> <code>ipmitool ... power diag</code> <code>6</code> <code>output</code> <code>ipmitool ... power soft</code> <p>You are supposed to define one driver per host:</p> <pre><code>kvmd:\ngpio:\ndrivers:\nmy_server:\ntype: ipmi\nhost: myserver.local\nuser: admin\npasswd: admin\nscheme:\nmy_server_status:\ndriver: my_server\npin: 0\nmode: input\nmy_server_on:\ndriver: my_server\npin: 1\nmode: output\nswitch: false\nmy_server_off:\ndriver: my_server\npin: 2\nmode: output\nswitch: false\nview:\ntable:\n- [my_server_status, \"my_server_on|On\", \"my_server_off|Off\"]\n</code></pre>"},{"location":"gpio/#wake-on-lan","title":"Wake-on-LAN","text":"Click to view <p>The driver <code>wol</code> provides a simple generator of Wake-on-LAN packages. One driver and one output are generated for one host if a simplified configuration method is used. However, you can define multiple drivers if you want to manage different hosts. One driver controls one host, and can only be used as an output. Pin numbers are ignored.</p> <pre><code>kvmd:\ngpio:\ndrivers:\nwol_server1:\ntype: wol\nmac: ff:ff:ff:ff:ff:f1\nwol_server2:\ntype: wol\nmac: ff:ff:ff:ff:ff:f2\nip: 192.168.0.100\nport: 9\nscheme:\nwol_server1:\ndriver: wol_server1\npin: 0\nmode: output\nswitch: false\nwol_server2:\ndriver: wol_server2\npin: 0\nmode: output\nswitch: false\nview:\ntable:\n- [\"#Server 1\", \"wol_server1|Send Wake-on-LAN\"]\n- [\"#Server 2\", \"wol_server2|Send Wake-on-LAN\"]\n</code></pre>"},{"location":"gpio/#cmd","title":"CMD","text":"Click to view <p>The <code>cmd</code> driver allows you to run custom command on PiKVM OS.</p> <p>Note</p> <p>This driver does not support bash operators, that is, it is a direct call to commands with arguments. For more complex cases, write your own shell scripts.</p> <p>Commands are executed from the user <code>kvmd</code>. If you want to run the command as root, then you need to configure <code>sudo</code>. Example of the <code>/etc/sudoers.d/custom_commands</code>:</p> <p>Granular example</p> <pre><code>kvmd ALL=(ALL) NOPASSWD: /usr/bin/reboot\n</code></pre> <p>NON Granular example (Captures ALL commands)</p> <pre><code>kvmd ALL=(ALL) NOPASSWD: ALL\n</code></pre> <p>Example of the <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>kvmd:\ngpio:\ndrivers:\nreboot:\ntype: cmd\ncmd: [/usr/bin/sudo, reboot]\nscheme:\nreboot_button:\ndriver: reboot\npin: 0\nmode: output\nswitch: false\nview:\ntable:\n- [\"reboot_button|confirm|Reboot PiKVM\"]\n</code></pre> <p>An example to help you get started:</p> <ul> <li><code>cmd: [/usr/bin/sudo, kvmd-otgconf, --disable-function, mass_storage.usb0]</code></li> <li><code>cmd: [(absolute path to sudo, command, flag, flag, absolute path to file]</code></li> </ul> <p>Then run the following:</p> <pre><code>systemctl restart kvmd\n</code></pre>"},{"location":"gpio/#pwm","title":"PWM","text":"Click to view <p>The <code>pwm</code> driver allows you to use some GPIO pins on the Raspberry Pi for PWM.</p> <p>Note</p> <p>Due to hardware limitations, this module conflicts with the kvmd-fan (PiKVM fan controller). To use it, you have to use hardware PWM for kvmfan. To do this, add the following lines to <code>/etc/kvmd/fan.ini</code>:</p> <pre><code>[main]\npwm_soft = 80\n</code></pre> <p>Here the small example with servo control:</p> <ol> <li> <p>Add to <code>/boot/config.txt</code>:</p> <pre><code>dtoverlay=pwm\n</code></pre> </li> <li> <p>Create <code>/etc/udev/rules.d/99-kvmd-pwm.rules</code>:</p> <pre><code>SUBSYSTEM==\"pwm*\", ACTION==\"add\", RUN+=\"/bin/chgrp -R kvmd /sys%p\", RUN+=\"/bin/chmod -R g=u /sys%p\"\nSUBSYSTEM==\"pwm*\", ACTION==\"change\", ENV{TRIGGER}!=\"none\", RUN+=\"/bin/chgrp -R kvmd /sys%p\", RUN+=\"/bin/chmod -R g=u /sys%p\"\n</code></pre> </li> <li> <p>Connect Servo motor like SG90 PWM connection to RPi GPIO18, +5V and GND to a 5V and GND pin on header:</p> </li> <li> <p>Add to /etc/kvmd/override.yaml</p> <pre><code>kvmd:\ngpio:\ndrivers:\nservo1:\ntype: pwm\nchip: 0                      # PWM Chip Number\nperiod: 20000000             # Servo Motor SG90 Period in nano-seconds\nduty_cycle_push: 1500000     # Servo Motor SG90 duty_cycle for pushing button\nduty_cycle_release: 1000000  # Servo Motor SG90 duty_cycle for releasing button\nscheme:\nshort_press:\ndriver: servo1\npin: 0  # Pin number is the PWM channel number on the PWM Chip\nmode: output\nswitch: false\npulse:\ndelay: 0.5\nmax_delay: 2\nlong_press:\ndriver: servo1\npin: 0\nmode: output\nswitch: false\npulse:\ndelay: 2\nmax_delay: 2\nextra_long_press:\ndriver: servo1\npin: 0\nmode: output\nswitch: false\npulse:\ndelay: 10\nmax_delay: 20\nview:\nheader:\ntitle: Controls\ntable:\n- [\"#Servo - Short Press\", \"short_press|Press\"]\n- [\"#Servo - Long Press\", \"long_press|Press\"]\n- [\"#Servo - Extra Long Press\", \"extra_long_press|Press\"]\n</code></pre> </li> </ol>"},{"location":"gpio/#servo","title":"Servo","text":"Click to view <p>The <code>servo</code> module is built on top of the <code>pwm</code> module and allows user to define angles instead of <code>duty_cyles</code> to control a PWM enabled servo motor like SG90. When the button is pressed the servo motor moves to an angle defined by <code>angle_push</code> and when button is released it moves back to <code>angle_release</code>. In the example configuration for a cheap 5V SG90 Servo, the motor moves to an angle of 45 degrees when button is pressed and moves back to 20 degress when released.</p> <p>Note</p> <p>Due to hardware limitations, this module conflicts with the kvmd-fan (PiKVM fan controller). To use it, you have to use hardware PWM for kvmfan. To do this, add the following lines to <code>/etc/kvmd/fan.ini</code>:</p> <pre><code>[main]\npwm_soft = 80\n</code></pre> <p>To use Servo motors in PiKVM you need to follow steps 1-3 for PWM Module and then use the following configuration.</p> <p>Add to <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>kvmd:\ngpio:\ndrivers:\nservo1:\ntype: servo\nchip: 0                  # PWM Chip Number\nperiod: 20000000         # Servo Motor SG90 Period in nano-seconds\nduty_cycle_min: 350000   # Servo Motor SG90 duty_cycle for -90 degrees\nduty_cycle_max: 2350000  # Servo Motor SG90 duty_cycle for +90 degrees\nangle_max: 90            # Servo Motor SG90 angle at duty_cycle_max\nangle_min: -90           # Servo Motor SG90 angle at duty_cycle_min\nangle_push: 45           # Servo Motor SG90 angle to push button\nangle_release: 20        # Servo Motor SG90 angle to release button\nscheme:\nshort_press:\ndriver: servo1\npin: 0  # Pin number is the PWM channel number on the PWM Chip\nmode: output\nswitch: false\npulse:\ndelay: 0.5\nmax_delay: 2\nlong_press:\ndriver: servo1\npin: 0\nmode: output\nswitch: false\npulse:\ndelay: 2\nmax_delay: 2\nextra_long_press:\ndriver: servo1\npin: 0\nmode: output\nswitch: false\npulse:\ndelay: 10\nmax_delay: 20\nview:\nheader:\ntitle: Controls\ntable:\n- [\"#Servo - Short Press\", \"short_press|Press\"]\n- [\"#Servo - Long Press\", \"long_press|Press\"]\n- [\"#Servo - Extra Long Press\", \"extra_long_press|Press\"]\n</code></pre>"},{"location":"gpio/#philips-hue","title":"Philips Hue","text":"Click to view <p>The <code>hue</code> module can control smartplugs and lamps over Philips Hue Bridge API. In general the plugin can switch any device on/off which is connected to the bridge. To use it you will need API token aka username:</p> <ol> <li>Open <code>http://bridge/debug/clip.html</code>.</li> <li>In the URL: Field type <code>/api/</code>.</li> <li>In the Message Body: Field type: <code>{\"devicetype\": \"pikvm\"}</code>.</li> <li>Hit the Get Button.</li> <li>As the Response you become the Username: <code>{\"success\": {\"username\": \"apiusername\"}</code>.</li> </ol> <p>Example:</p> <pre><code>kvmd:\ngpio:\ndrivers:\nhue:\ntype: hue\nurl: http://bridge\ntoken: YG-xxxxxxxxxxxx\nscheme:\nplug_button:\ndriver: hue\npin: 32\nmode: output\ninitial: null\nswitch: true\npulse:\ndelay: 0\nplug_led:\ndriver: hue\npin: 32\nmode: input\nview:\ntable:\n- [\"plug_led\", \"plug_button\"]\n</code></pre>"},{"location":"gpio/#anel-net-pwrctrl","title":"ANEL NET-PwrCtrl","text":"Click to view <p>The <code>anelpwr</code> plugin allows you to use ANEL NET-PwrCrtl IP-PDUs (switchabel sockets) as gpios. There are up to 8 Ports per PDU. Input pulls the the current state from the PDU, Output switches the Socket. </p> <pre><code>kvmd:\ngpio:\ndrivers:\nanel_pdu_0:\ntype: anelpwr\nurl: http://IP:port\nuser: admin\npasswd: anel\nscheme:\npdu0_0_pwr:\npin: 0\ndriver: anel_pdu_0\nmode: output\npulse:\ndelay: 0\npdu0_0_led:\npin: 0\ndriver: anel_pdu_0\nmode: input\nview:\nheader:\ntitle: \"PDUs\"\ntable:\n- [\"#PDU0\"]\n- []\n- [\"#PDU0_Port0:\", pdu0_0_led, \"pdu0_0_pwr|confirm|test\"] </code></pre>"},{"location":"ipmi/","title":"IPMI & Redfish integration","text":""},{"location":"ipmi/#ipmi-redfish","title":"IPMI &amp; Redfish","text":"<p>Info</p> <p>This page is about the server-side emulation (if you want to manage PiKVM using ipmitool or so). If you want to use the PiKVM Web UI to manage the server using IPMI (that is, as an IPMI client), see GPIO functions with IPMI plugin.</p>"},{"location":"ipmi/#ipmi-bmc","title":"IPMI BMC","text":"<p>IPMI is an old protocol for remote server management. It can be useful for managing a large number of machines with PiKVM. Its advantage is that it is supported by many enterprise systems.</p> <p>Warning</p> <p>Although PiKVM supports the IPMI protocol, we strongly recommend that you DO NOT USE IT outside of trusted networks due to the protocol's insecurity. Use Redfish or KVMD API instead of it. Also IPMI can not work with 2FA.</p> <p>To enable IPMI BMC follow these steps:</p> <ol> <li> <p>Switch the filesystem to the RW-mode:</p> <pre><code># rw\n</code></pre> </li> <li> <p>Setup IPMI account in file <code>/etc/kvmd/ipmipasswd</code>.</p> </li> <li> <p>Enable <code>kvmd-ipmi</code> daemon:</p> <pre><code># systemctl enable --now kvmd-ipmi\n</code></pre> </li> <li> <p>Switch the filesystem back to the RO:</p> <pre><code># ro\n</code></pre> </li> <li> <p>Here some examples (on the remote PC):</p> <pre><code>$ ipmitool -I lanplus -U admin -P admin -H pikvm power status\n$ ipmitool -I lanplus -U admin -P admin -H pikvm power on\n</code></pre> </li> </ol>"},{"location":"ipmi/#ipmi-sol","title":"IPMI SoL","text":"<p>IPMI supports the ability to get console access to the server using Serial-over-LAN. PiKVM can act as a proxy for your server's COM port.</p> <p>Warning</p> <p>Although PiKVM supports the IPMI protocol, we strongly recommend that you DO NOT USE IT outside of trusted networks due to the protocol's insecurity. Use Redfish or KVMD API instead of it.</p> <p>To use this feature, you will need a USB-COM adapter that you need to connect to the PiKVM. The COM port of the adapter need to be connected to the server. As with IPMI BMC, you need to configure <code>kvmd-vnc</code> and add the following configuration to <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>ipmi:\nsol:\ndevice: /dev/ttyUSB0  # Path of your USB-COM adapter\nspeed: 115200\n</code></pre> <p>After enabling <code>kvmd-ipmi</code>, all requests that it receives over the network regarding the COM port will be forwarded to your server. For example:</p> <pre><code>$ ipmitool -I lanplus -U admin -P admin -H pikvm sol activate\n</code></pre>"},{"location":"ipmi/#redfish","title":"Redfish","text":"<p>Redfish is a more modern server management protocol designed to replace IPMI. It is based on HTTP and fixes many security issues. If possible, we recommend using it instead of IPMI, or using the KVMD API.</p> <p>There're not special actions required to use Redfish. In addition, Redfish will use regular PiKVM credentials. But for systems that have been upgraded to KVMD 2.0 (not a clean image installation), you will probably need to edit the <code>/etc/kvmd/nginx/kvmd.ctx-server.conf</code> file to add these lines at the end:</p> <pre><code>location /redfish {\nproxy_pass http://kvmd;\ninclude /etc/kvmd/nginx/loc-proxy.conf;\nauth_request off;\n}\n</code></pre> <p>Info</p> <p>Don't be confused by the parameter <code>auth_request off</code>. KVMD performs authorization on its own. The only open HTTP entrypoint is <code>/redfish/v1</code>, which returns a static document and does not change the state of the PiKVM. It's safe.</p> <p>If there is a file in your system after the update <code>/etc/kvmd/nginx/kvmd.ctx-server.conf.pacnew</code> you can just move it:</p> <pre><code># mv /etc/kvmd/nginx/kvmd.ctx-server.conf.pacnew /etc/kvmd/nginx/kvmd.ctx-server.conf\n</code></pre> <p>Warning</p> <p>Be careful not to lose your local changes if you have done anything with this file before.</p> <p>To access the Redfish API, use HTTP Basic Auth. Also you can use the redfishtool:</p> <pre><code>$ redfishtool -S Never -r pikvm root\n$ redfishtool -S Never -u admin -p admin -r pikvm Systems\n$ redfishtool -S Never -u admin -p admin -r pikvm Systems reset ForceOff\n</code></pre>"},{"location":"letsencrypt/","title":"Let's Encrypt certificates","text":""},{"location":"letsencrypt/#lets-encrypt-certificates","title":"Let's Encrypt certificates","text":"<p>PiKVM uses self-signed SSL certificates out of the box. If you have a domain name, you can use Let's Encrypt certificates.</p> <p>Usually Let's Encrypt certificates are issued and updated automatically using Certbot, however, since PiKVM uses a read-only file system, special tools around Certbot are required to work with certificates. KVMD 3.117 provides them.</p> <p>Note</p> <p>This feature is available on images as old as 2022.06.19 since it requires PST storage partition on SD card. Ports 80+443 need to be opened if you are port forwarding for this to work properly.</p>"},{"location":"letsencrypt/#basic-setup","title":"Basic setup","text":"<ol> <li> <p>Update the OS and make sure that you are using a new image with PST storage.</p> <pre><code># rw\n# pacman -Syu\n# reboot\n...\n# kvmd-pstrun -- true\n</code></pre> <p>If the storage is not available, you need to reflash the OS image to the latest one from our official website.</p> </li> <li> <p>Switch filesystem to RW and obtain the certificate (for example, <code>pikvm.example.com</code>. The method depends on the network configuration. In the simplest case, if PiKVM is open for access from the Internet, it is recommended to use the webroot. Another examples will be described below.</p> <pre><code># rw\n# kvmd-certbot certonly_webroot --agree-tos -n --email user@example.com -d pikvm.example.com\n</code></pre> </li> <li> <p>Install the certificate for KVMD-Nginx and (optionally) KVMD-VNC. Running services will be restarted/reloaded automatically. Switch filesystem to RO.</p> <pre><code># kvmd-certbot install_nginx pikvm.example.com\n# kvmd-certbot install_vnc pikvm.example.com\n# ro\n</code></pre> </li> <li> <p>Check the renewal immediately, just for testing:</p> <pre><code># kvmd-certbot renew --force-renewal\n</code></pre> </li> <li> <p>Enable automatic certificate renewal:</p> <pre><code># rw\n# systemctl enable --now kvmd-certbot.timer\n# ro\n</code></pre> </li> </ol>"},{"location":"letsencrypt/#cloudflare-dns","title":"Cloudflare DNS","text":"<p>This example shows that PiKVM may not be accessible from the internet, but you can still get a certificate if you use Cloudflare DNS.</p> <ol> <li> <p>Switch filesystem to RW and install the Cloudflare DNS plugin:</p> <pre><code># rw\n# pacman -S certbot-dns-cloudflare\n</code></pre> </li> <li> <p>Prepare the environment for the DNS plugin (place the auth data):</p> <pre><code># kvmd-pstrun -- mkdir -p /var/lib/kvmd/pst/data/certbot/runroot\n# kvmd-pstrun -- nano /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth\n# kvmd-pstrun -- chmod 600 /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth\n</code></pre> </li> <li> <p>Obtain the certificate:</p> <pre><code># kvmd-certbot certonly \\\n   --dns-cloudflare \\\n   --dns-cloudflare-propagation-seconds 60 \\\n   --dns-cloudflare-credentials /var/lib/kvmd/pst/data/certbot/runroot/.cloudflare.auth \\\n   --agree-tos \\\n   -n \\\n   --email user@example.com \\\n   -d pikvm.example.com\n</code></pre> </li> <li> <p>Next follow the basic guide.</p> </li> </ol>"},{"location":"letsencrypt/#route53-dns","title":"Route53 DNS","text":"<p>This example shows that PiKVM may not be accessible from the internet, but you can still get a certificate if you use AWS Route53 DNS. Make sure you are running an image newer than 2022.06.20 and kvmd version 3.119-1 or greater.</p> <ol> <li> <p>Switch filesystem to RW and install the Route53 DNS plugin:</p> <pre><code># rw\n# pacman -S certbot-dns-route53\n</code></pre> </li> <li> <p>Configure Your AWS User       For the certbot_dns_route53 plugin to work it needs to be able to connect to AWS using an access key with the correct permissions.</p> <p>To do this securely you\u2019ll want to create a new AWS user that only has the necessary permissions it needs to work.</p> <p>You can find instructions for creating a user here. The basics of it is you\u2019ll want a user with Programmatic access (not console), add it to a group (I created a new one just for this user and any future certbot users I might need).</p> <p>The user will need specific permissions that are required to allow the certbot plugin to create the necessary CNAME records. These can be added by manually selecting them from a very long list or you can use the json view to give it the following permissions.</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": [\"route53:ListHostedZones\", \"route53:GetChange\"],\n\"Resource\": [\"*\"]\n},\n{\n\"Effect\": \"Allow\",\n\"Action\": [\"route53:ChangeResourceRecordSets\"],\n\"Resource\": [\"arn:aws:route53:::hostedzone/YOURHOSTEDZONEID\"]\n}\n]\n}\n</code></pre> <p>Make sure you replace YOURHOSTEDZONEID with the instance ID of your hosted zone.</p> <p>Once the user is created don\u2019t forget to download and save your access key and secret access key (somewhere secure, these are as sensitive as your passwords).</p> </li> <li> <p>Setup credentials:</p> <p>We now need to put the AWS credentials on the PiKVM so the certbot can use them.</p> <pre><code># kvmd-pstrun -- mkdir -p /var/lib/kvmd/pst/data/certbot/runroot\n</code></pre> <p>Copy and paste your AWS credentials into the nano editor and save the file.</p> <pre><code># kvmd-pstrun -- nano /var/lib/kvmd/pst/data/certbot/runroot/.route53.auth\n</code></pre> <p>Here is an example .route53.auth file. Replace the placeholders with the access key and secret access key that you just saved from AWS and fill them in.</p> <pre><code>[default]\naws_access_key_id=XXXXXX\naws_secret_access_key=XXXX/XXXXX\n</code></pre> <p>Update permissions:</p> <pre><code># kvmd-pstrun -- chmod 600 /var/lib/kvmd/pst/data/certbot/runroot/.route53.auth\n</code></pre> </li> <li> <p>Obtain the certificate:</p> <pre><code># export AWS_SHARED_CREDENTIALS_FILE=\"/var/lib/kvmd/pst/data/certbot/runroot/.route53.auth\"\n# kvmd-certbot certonly \\\n   --dns-route53 \\\n   --agree-tos \\\n   -n \\\n   --email user@example.com \\\n   -d pikvm.example.com\n</code></pre> </li> <li> <p>Enable automatic certificate renewal:</p> <p>Create the file: <code>/etc/conf.d/kvmd-certbot</code> with the following contents so the renewall service can find the authentication file containing the AWS credentials:</p> <pre><code>AWS_SHARED_CREDENTIALS_FILE=\"/var/lib/kvmd/pst/data/certbot/runroot/.route53.auth\"\n</code></pre> <p>Now enable the renewal service:</p> <pre><code># systemctl enable --now kvmd-certbot.timer\n</code></pre> </li> </ol>"},{"location":"letsencrypt/#acme-dns","title":"ACME DNS","text":"<p>ACME DNS is a \"Limited DNS server with RESTful HTTP API to handle ACME DNS challenges easily and securely.\" The acme-dns-client works, in conjunction, with Certbot (<code>kvmd-certbot</code>) to enable <code>DNS-01</code> challenge support via ACME DNS.</p> <p>These instructions are for how to install and use the <code>acme-dns-client</code> with ACME DNS for PiKVM.</p>"},{"location":"letsencrypt/#assumptions","title":"Assumptions","text":"<ul> <li>ACME DNS is already set up and functioning in the environment</li> <li>ACME DNS Server is <code>auth.example.org</code></li> <li>PiKVM Fully Qualified Domain Name (FQDN) is <code>pikvm.example.org</code></li> <li>PiKVM is running on a supported Raspberry Pi using the PiKVM OS (which is 32-bit as of the writing of this documentation)</li> <li>All configuration examples below are as user <code>root</code> via a terminal session to PiKVM</li> </ul>"},{"location":"letsencrypt/#not-in-scope","title":"Not in Scope","text":"<ul> <li>Installation and Setup of ACME DNS Server</li> </ul>"},{"location":"letsencrypt/#instructions","title":"Instructions","text":"<ol> <li>Ensure that Step 1 from Basic Setup has been completed</li> <li>Visit the Releases page to get the download URL for the latest <code>acme-dns-client</code> release (PiKVM OS is 32-bit, which is <code>linux_armv6</code>)</li> <li> <p>Install <code>acme-dns-client</code></p> <p>The <code>acme-dns-client</code> is not distributed by <code>pacman</code> and is a manual installation. The steps below are for:</p> <ul> <li>Creating a folder for <code>acme-dns-client</code></li> <li>Downloading and extracting the <code>acme-dns-client</code> TAR from Github</li> <li>Moving the <code>acme-dns-client</code> binary to the created folder</li> <li>Cleaning up files from the download</li> <li>Creating the necessary persistent symbolic link to allow <code>acme-dns-client</code> to be ran</li> <li>Initialize <code>acme-dns-client</code></li> </ul> <p>Note</p> <p>Make sure to replace the URL below with the one gathered from Step 1. As of the writing of this documentation: - The latest (and demonstrated) version is v0.3 - (Demonstrated) Platform is <code>linux-armv6</code> </p> <pre><code># mkdir /etc/acmedns\n# curl -LO https://github.com/acme-dns/acme-dns-client/releases/download/v0.3/acme-dns-client_0.3_linux_armv6.tar.gz\n# tar -zxvf acme-dns-client_0.3_linux_armv6.tar.gz\n# mv acme-dns-client /etc/acmedns/acme-dns-client\n# ln -sf /etc/acmedns/acme-dns-client /usr/local/bin/acme-dns-client\n# rm LICENSE README.md acme-dns-client_0.3_linux_armv6.tar.gz\n# acme-dns-client\n</code></pre> </li> <li> <p>Register <code>acme-dns-client</code> with ACME DNS  </p> <p>Note</p> <p>This is interactive, follow instructions for creating and verifying the appropriate <code>CNAME</code> record.  </p> <pre><code># acme-dns-client register -d pikvm.example.org -s http://auth.example.org\n</code></pre> <p>Once registration is complete ownership of <code>clientstorage.json</code> must be changed to <code>kvmd-certbot</code>.</p> <pre><code># chown kvmd-certbot:kvmd-certbot /etc/acmedns/clientstorage.json\n</code></pre> <p>Note</p> <p>If using <code>acme-dns-client</code> on an internal/private domain with an ACME compatible Certificate Authority do not forget to add <code>-ns &lt;dns-server-ip&gt;:&lt;dns-server-port&gt;</code> to <code>acme-dns-client register</code></p> </li> <li> <p>Register Certbot</p> <pre><code># kvmd-certbot register\n</code></pre> </li> <li> <p>Request Certificate via Certbot</p> <pre><code># kvmd-certbot certonly --manual --preferred-challenges dns --manual-auth-hook 'acme-dns-client' -d pikvm.example.org\n</code></pre> <p>Note</p> <p>If using an ACME compatible Certificate Authority (other than Let's Encrypt) do not forget to add <code>--server https://ca.example.org/acme/acme/directory</code> to <code>kvmd-certbot</code></p> </li> <li> <p>Follow steps 3 through 5 under Basic Setup to complete setup and renewal of certificates</p> </li> </ol>"},{"location":"letsencrypt/#wireguard-proxy","title":"Wireguard proxy","text":"<p>If you don't have public IP, and you don't want to put your API keys in PiKVM, you can forward HTTP traffic over wireguard. To Let's Encrypt you'll appear to serve ACME challenges from a host they can reach from the Internet (e.g. VPS), to which you'll connect over wireguard.</p>"},{"location":"letsencrypt/#assumptions_1","title":"Assumptions","text":"<ul> <li>FQDN of your pikvm is <code>pikvm1.int.example</code>;</li> <li>FQDN of the proxy VPS is <code>acme-proxy.example</code>;</li> <li>public IP addresses of VPS are <code>198.51.100.1</code> and <code>2001:db8::1</code>;</li> <li>internal (wireguard) IPv4 address of the PiKVM is <code>10.11.12.13</code>.</li> </ul>"},{"location":"letsencrypt/#instructions_1","title":"Instructions","text":"<ol> <li> <p>Setup wireguard and ensure it's working.</p> </li> <li> <p>Setup public DNS zone to point the domain address at the public VPS:</p> <pre><code>acme-proxy.example. IN A      198.51.100.1\nacme-proxy.example. IN AAAA   2001:db8::1\npikvm1.int.example. IN CNAME  acme-proxy.example.\n</code></pre> </li> <li> <p>On the public VPS, configure HTTP proxy to forward       <code>/.well-known/acme-challenge</code> to PiKVM. For example in nginx:</p> <pre><code>server {\nlisten 80;\nlisten [::]:80;\n\nserver_name pikvm1.int.example;\n\nlocation ^~ /.well-known/acme-challenge {\nproxy_pass http://10.11.12.13:80;\nproxy_set_header Host $host;\n}\n\nlocation / {\nreturn 404;\n}\n}\n</code></pre> </li> <li> <p>Now you can use <code>kvmd-certbot certonly_webroot</code> as in basic scenario above.</p> </li> </ol>"},{"location":"mouse/","title":"Mouse modes","text":""},{"location":"mouse/#mouse","title":"Mouse","text":"<p>There are two modes of pointer device: absolute and relative.</p> <p>In absolute mode, the input device transmits the exact coordinates <code>(X,Y)</code> where the cursor should be moved. This is how touchscreens or drawing tablets work.</p> <p>In relative mode, only the relative offset <code>(dX,dY)</code> to the current position is transmitted, which is unknown to the input device itself. This is a regular mouse.</p> <p>By default, PiKVM uses absolute positioning mode as the most convenient for the user and software. However, this is not always supported by the BIOS/UEFI. For such cases, support is provided for the relative mode of operation, which can be enabled in the config.</p> <p>When using relative mode, the browser will exclusively capture your mouse when you click on the stream window in PiKVM once. When you press <code>Esc</code>, the browser releases the mouse.</p>"},{"location":"mouse/#important-notes","title":"Important notes","text":"<p>The relative mouse generates a huge number of events that can be poorly transmitted over the network or very slowly perceived by the BIOS/UEFI driver. To solve this problem, mouse events are optimized using a vector sum. This mode is enabled by activating the below first and is available in the web menu <code>System -&gt; Squash mouse moves</code>. You can try disabling this if you have problems with mouse acceleration. This is the best and most reasonable compromise right now.</p> <p>Also currently the relative mouse mode is not supported by PiKVM VNC server yet. The reason is that none of the recommended clients support the QEMU Pointer Motion Change extension.  We expect to implement this in TigerVNC. The relative mode is also not supported by mobile browsers.</p>"},{"location":"mouse/#relative-mouse-on-v2-platform-otg-hid","title":"Relative mouse on V2+ platform (OTG HID)","text":"<p>Info</p> <p>On PiKVM V4 dual mode is enabled by default. To disable it and enable single mode, set <code>kvmd/hid/mouse_alt/device</code> (see below) to empty string:</p> <pre><code>kvmd:\nhid:\nmouse_alt:\ndevice: \"\"\n</code></pre>"},{"location":"mouse/#dual-mode","title":"Dual mode","text":"<p>Using dual mouse mode you can switch between the absolute and relative mouse in the <code>System</code> menu without reloading. This is more convenient, but for compatibility reasons it is disabled by default. To enable it, do the following:</p> <ol> <li> <p>Switch filesystem to RW-mode using command <code>rw</code>.</p> </li> <li> <p>Edit <code>/etc/kvmd/override.yaml</code> and add these lines:</p> <pre><code>kvmd:\nhid:\nmouse_alt:\ndevice: /dev/kvmd-hid-mouse-alt\n</code></pre> </li> <li> <p>Perform <code>reboot</code>. After that reboot your PC.</p> </li> </ol>"},{"location":"mouse/#single-relative-mode","title":"Single relative mode","text":"<ol> <li> <p>Switch filesystem to RW-mode using command <code>rw</code>.</p> </li> <li> <p>Edit <code>/etc/kvmd/override.yaml</code> and add these lines:</p> <pre><code>kvmd:\nhid:\nmouse:\nabsolute: false\n</code></pre> </li> <li> <p>Perform <code>reboot</code>. After that reboot your PC.</p> </li> <li> <p>If the mouse is still not detected by the BIOS/UEFI, try disabling horizontal scrolling to achieve the maximum compatibility:</p> <pre><code>kvmd:\nhid:\nmouse:\nabsolute: false\nhorizontal_wheel: false\n</code></pre> </li> <li> <p>Don't forget to perform <code>reboot</code>.</p> </li> </ol>"},{"location":"mouse/#relative-mouse-on-v0-platform-arduino-hid","title":"Relative mouse on V0 platform (Arduino HID)","text":"<p>Mode switching for Arduino HID can be performed on-the-fly starting with KVMD 2.6 and the corresponding firmware. No additional actions are required.</p>"},{"location":"mouse/#fixing-the-absolute-mouse-on-windows-98","title":"Fixing the absolute mouse on Windows 98","text":"<p>Due to an ancient buggy driver, the absolute mouse on Windows 98 moves only within the upper-left quarter of the screen. To fix this, you need to activate some magic workaround in <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>kvmd:\nhid:\nmouse:\nabsolute_win98_fix: true\n</code></pre> <p>... and run <code>systemctl restart kvmd</code>.</p>"},{"location":"msd/","title":"Mass Storage Drive","text":""},{"location":"msd/#mass-storage-drive","title":"Mass Storage Drive","text":""},{"location":"msd/#basics","title":"Basics","text":"<p>This is a feature available on PiKVM v2+ that allows you to emulate a CD-ROM or Flash Drive.</p> <p>There are some subtleties that you should know:</p> <p>The size of the CD-ROM image is limited to 2.2 GB</p> <p>This is a limitation of the Linux kernel, which currently cannot emulate a DVD. To use a larger boot image, use Flash emulation. If this is not possible (the image does not support Flash, for example, for Windows), use this recipe.</p> <p>Changing the media type between CD-ROM and Flash is possible only when the device is reconnected</p> <p>For PiKVM v3 HAT, this can be done using the switch <code>System -&gt; Connect main USB</code>. In this case, the media type is determined at the time of connecting the image, and not by clicking on the switch. The switch affects the settings of the future connection. For non-v3 devices, you need to either reboot your server or otherwise reinitialize the connection.</p>"},{"location":"msd/#upload-images-manually-without-web-ui","title":"Upload images manually (without Web UI)","text":"<p>This instruction is relevant for KVM &gt;= 3.203. If you are using a previous version, then update OS.</p> <ol> <li> <p>Remount internal storage to rw (read-write):</p> <pre><code># kvmd-helper-otgmsd-remount rw\n</code></pre> </li> <li> <p>Upload the .ISO image(s) to <code>/var/lib/kvmd/msd</code> via scp or similar.</p> </li> <li> <p>Create an empty file in <code>/var/lib/kvmd/msd</code> with the exact name (case sensitive!) of the uploaded image + prefix <code>.__</code> and suffix <code>.complete</code>. This will indicate PiKVM that the uploaded image is okay and can be used. For example:</p> <pre><code>/var/lib/kvmd/msd/.__ubuntu-18.04.4-desktop-amd64.iso.complete\n</code></pre> </li> <li> <p>Remount internal storage back to ro (read-only):</p> <pre><code># kvmd-helper-otgmsd-remount ro\n</code></pre> </li> </ol>"},{"location":"msd/#nfs-storage","title":"NFS storage","text":"<p>This instruction is relevant for KVM &gt;= 3.206. If you are using a previous version, then update OS.</p> <p>It is possible to create a shared image storage for an entire fleet of PiKVMs using NFS.</p> <p>If you have some shares, you can easily connect them to PiKVM by creating mount points and adding relevant records to <code>/etc/fstab</code>. At the same time, you will be able to upload images via PiKVM Web UI to NFS, and still use local storage.</p> <pre><code># rw\n# pacman -Syu\n# pacman -S nfs-utils\n# kvmd-helper-otgmsd-remount rw\n# mkdir -p /var/lib/kvmd/msd/NFS_Primary\n# mkdir -p /var/lib/kvmd/msd/NFS_Secondary\n# kvmd-helper-otgmsd-remount ro\n</code></pre> <p>Edit fstab:</p> <pre><code>server:/srv/nfs/NFS_Primary    /var/lib/kvmd/msd/NFS_Primary    nfs vers=3,timeo=1,retrans=1,soft,nolock  0 0\nserver:/srv/nfs/NFS_Secondary  /var/lib/kvmd/msd/NFS_Secondary  nfs vers=3,timeo=1,retrans=1,soft,nolock  0 0\n</code></pre> <p>And perform <code>reboot</code>.</p> <p>Make sure that the <code>kvmd</code> user has read access rights from these directories. You can also give write access if needed. For the best performance, it is required to ensure reliable connectivity with NFS server and use minimum <code>timeo</code> and <code>retrans</code> values. Using the <code>soft</code> option is mandatory, <code>nolock</code> is recommended.</p> <p>Note if an image is added to the NFS storage from the outside, PiKVM will not be able to track this event, so it is required to use <code>Drive -&gt; Reset</code> in the Web UI to update the list of images.</p> <p>Configuring an NFS server is beyond the scope of this guide.</p>"},{"location":"msd/#multiple-and-writable-drives","title":"Multiple and writable drives","text":"<p>Unless explicitly disabled by default, PiKVM creates only one drive for Mass Storage emulation. However, you can create additional drives and manage them manually via the terminal. This is useful if you want to boot the server from a ISO CD (specified in the web interface), then connect a virtual flash drive to the server and download some files from to PiKVM from it.</p> <p>Info</p> <p>The presence of an additional Mass Storage Drive should not interfere with the boot, but for reasons of compatibility paranoia, this is disabled by default. We recommend setting up the drives in advance, making sure that booting from the ISO CD is still working, and then using the drives as needed.</p> USB limitations <p>TL;DR: By default, you can add only one additional device to choose from, such as USB Ethernet, or USB Serial, or an extra Mass Storage Drive.</p> <p>There is a hardware limit on the number of devices that can be emulated at the same time. Each USB device uses so-called endpoints to communicate with the host. Depending on the type, the device consumes a different number of endpoints, while their total number is limited by the capabilities of the chip, for Raspberry Pi it is 8.</p> <p>It is quite difficult to calculate the number of endpoints used, but in the case of PiKVM, you can focus on the following numbers:</p> Device Endpoints Keyboard, mouse 1 for each Mass Storage Drive 2 for each USB Ethernet, USB Serial 3 for each <p>V2 and V3 emulates one mouse by default, V4 emulates two mouses. Thus, V2 and V3 use 4 endpoints, and V4 uses 5 by default.</p> <p>Creating an axtra Mass Storage Drive consumes additional endpoints, as well as USB Serial and USB Ethernet, so only a limited number of devices can be selected for the final configuration, for example, one USB Ethernet.</p> <p>If you need something more non-standard, you can disable the regular Mass Storage Drive and the additional mouse (on V4) to free up some extra endpoints.</p> <p>The <code>kvmd-otg</code> service is responsible for setting up USB emulation. If the endpoint limit is exceeded, the service will not be able to start and no emulated USB device will work.</p> <p>In the log it looks something like this:</p> <pre><code># journalctl -u kvmd-otg\n...\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- ===== Preparing complete =====\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- Enabling the gadget ...\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- WRITE --- /sys/kernel/config/usb_gadget/kvmd/UDC\nkvmd-otg[382]: OSError: [Errno 524] Unknown error 524\nkvmd-otg[382]: During handling of the above exception, another exception occurred:\nkvmd-otg[382]: Traceback (most recent call last):\nkvmd-otg[382]:   File \"/usr/bin/kvmd-otg\", line 9, in &lt;module&gt;\nkvmd-otg[382]:     main()\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 348, in main\nkvmd-otg[382]:     options.cmd(config)\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 278, in _cmd_start\nkvmd-otg[382]:     _write(join(gadget_path, \"UDC\"), udc)\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 83, in _write\nkvmd-otg[382]:     with open(path, \"w\") as file:\nkvmd-otg[382]: OSError: [Errno 524] Unknown error 524\nsystemd[1]: kvmd-otg.service: Main process exited, code=exited, status=1/FAILURE\nsystemd[1]: kvmd-otg.service: Failed with result 'exit-code'.\nsystemd[1]: Failed to start PiKVM - OTG setup.\n</code></pre> <p>In this case, you need to disable some of the previously enabled devices and restart PiKVM.</p>"},{"location":"msd/#how-to-enable-extra-drives","title":"How to enable extra drives","text":"<ol> <li> <p>Switch the root filesystem to <code>rw</code> mode.</p> </li> <li> <p>Edit <code>/etc/kvmd/override.yaml</code> and add these lines:</p> <pre><code>otg:\ndevices:\ndrives:\nenabled: true  # Set it to true to enable\ncount: 1  # +1 drive, default value\ndefault:  # Default configuration for the all extra drives\ncdrom: false  # Default value (false for the generic flash drive)\nrw: false # Read-only by default\n</code></pre> <p>If you specify <code>count: N</code>, you will create <code>N</code> additional drives configured the same way, as described in the <code>default</code> section.</p> </li> <li> <p>Perform <code>reboot</code>.</p> </li> </ol>"},{"location":"msd/#how-to-create-a-second-rw-flash-drive","title":"How to create a second RW flash drive","text":"<ol> <li> <p>Switch the root filesystem to <code>rw</code> mode:</p> <pre><code># rw\n</code></pre> </li> <li> <p>Create the empty image file of the desire size (1Gb in this example).</p> <pre><code># dd if=/dev/zero of=/root/flash.img bs=1M count=1000 status=progress\n</code></pre> </li> <li> <p>Connect it to the drive 1:</p> <pre><code># kvmd-otgmsd -i 1 --set-rw=1 --set-cdrom=0 --set-image=/root/flash.img\n</code></pre> <p>After that you will have access to the flash drive from the target server. Drive 0 represents a drive that is controlled via a web interface and API. Don't use it with kvmd-otgmsd if you don't know exactly what you're doing.</p> </li> <li> <p>View the driver state:</p> <pre><code># kvmd-otgmsd -i 1\nImage file:  /root/flash.img\nCD-ROM flag: no\nRW flag:     yes\n</code></pre> </li> <li> <p>To disable the flash drive and view the files on it from the KVM, run:</p> <pre><code># kvmd-otgmsd -i 1 --unlock --eject\n</code></pre> <p>This command will interrupt the current IO operation on ALL DRIVES including the one that is managed via the web interface. The same result is achieved by clicking the disable media button in the web interface. Right now, the Linux kernel does not allow to distinguish between internal threads that manage different drives. It is recommended to eject the media when you know that this will not cause problems for the other media.</p> </li> <li> <p>Don't forget to remount the root filesystem to read-only mode:</p> <pre><code># ro\n</code></pre> </li> <li> <p>You can download the resulting image via SCP or mount it as a loop device on the PiKVM.</p> </li> </ol>"},{"location":"msd/#disable-msd","title":"Disable MSD","text":"<p>To disable mass storage emulation altogether, you can place the following piece of configuration into <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>kvmd:\nmsd:\ntype:  disabled\n</code></pre>"},{"location":"msd/#create-a-windows-based-flash-disk-image","title":"Create a Windows based Flash disk image","text":"<p>An alternative version of this can be found below that does not require a physical usb flash</p> <p>This procedure will create a disk image of a USB stick. This is mostly required for Windows based images since they are larger than the CDROM based limit of 2.2GB. You can create a bootable USB stick with the normal Microsoft tools, e.g. Media Creation Tool. Creating a bootable USB stick can also be made from an ISO file with other tools like Rufus.</p> <p>Without resizing, the full size of the USB stick will be used, so keep the stick as small as possible (e.g. 4GB or 8GB) but still large enough for all Windows files. The Media Creation tool will tell you what the minimum size is.</p> <p>Before creating the image file, you can use a tool like \"EaseUS Partition Master Free\" or \"GParted\" to resize the main FAT32 partition on the USB stick. This will save space on PiKVM.</p> <p>You can also perform these steps on a separate unix machine and transfer the image over to pikvm with e.g. SCP. Or, on Windows you could use a program like PassMark ImageUSB (only for full USB size images) or 'dd' for Windows to create the image. Then use WinSCP to transfer the image over to PiKVM.</p> <p>Once you have the desired USB stick perform the following on the RPi to create the image directly to the PiKVM image storage folder.</p> <ol> <li> <p>Insert Windows based USB stick into Pi4, generated with Microsoft USB creation tool. SSH to PiKVM as root.</p> <pre><code># dmesg\n[ 3025.025401] usb-storage 2-1:1.0: USB Mass Storage device detected\n[ 3025.038911] scsi host0: usb-storage 2-1:1.0\n[ 3026.132248] scsi 0:0:0:0: Direct-Access     Kingston DataTraveler 3.0 PMAP PQ: 0 ANSI: 6\n[ 3026.771425] sd 0:0:0:0: [sda] 15360000 512-byte logical blocks: (7.86 GB/7.32 GiB)\n[ 3026.790276] sd 0:0:0:0: [sda] Write Protect is off\n[ 3026.802530] sd 0:0:0:0: [sda] Mode Sense: 23 00 00 00\n[ 3026.804450] sd 0:0:0:0: [sda] No Caching mode page found\n[ 3026.814082] sd 0:0:0:0: [sda] Assuming drive cache: write through\n[ 3026.908712]  sda: sda1\n[ 3026.922794] sd 0:0:0:0: [sda] Attached SCSI removable disk\n[root@pikvm ~]#\n</code></pre> <p>USB devices shows as <code>sda</code>. We will use <code>sda1</code> as the Windows partition.</p> </li> <li> <p>mount msd folder as read/write</p> <pre><code># kvmd-helper-otgmsd-remount rw\n</code></pre> </li> <li> <p>Create image of USB data PARTITION to an image file, this will take some time, in this case about 12 minutes (RPi4).</p> <pre><code># dd if=/dev/sda1 of=/var/lib/kvmd/msd/windows10-2004.bin bs=8M status=progress\n4458545152 bytes (4.5 GB, 4.2 GiB) copied, 736 s, 6.1 MB/s\n531+1 records in\n531+1 records out\n4458545152 bytes (4.5 GB, 4.2 GiB) copied, 736.213 s, 6.1 MB/s\n</code></pre> </li> <li> <p>Correct ownership of new image and make sure the website reports the file as complete (pay attention to the different folder).</p> <pre><code># chown kvmd:kvmd /var/lib/kvmd/msd/windows10-2004.bin\n# touch /var/lib/kvmd/msd/windows10-2004.bin.complete\n</code></pre> </li> <li> <p>Remount msd folder as read only</p> <pre><code># kvmd-helper-otgmsd-remount ro\n</code></pre> </li> <li> <p>On PiKVM webpage, under Storage select the new image and connect it in Drive Mode: Flash to the server.</p> </li> </ol> <p>Boot the server and select boot device like you normally would. E.g. in a AMI BIOS the boot device is called \"Linux File-CD Gadget 0504\".</p>"},{"location":"msd/#create-a-drive-image-on-macos","title":"Create a drive image on macOS","text":"<ol> <li>Open Disk Utility.</li> <li><code>File &gt; New Image &gt; Blank Image</code>.</li> <li>Save As: <code>pikvm-image.dmg</code>. Name: <code>pikvm-image</code>. Size: 100 MB (or whatever size you want). Format: <code>MS-DOS (FAT)</code>. Partitions: <code>Single partition - GUID Partition Map</code>. Image Format: <code>read/write disk image</code>.</li> <li>Click Save.</li> <li>The drive will automatically be mounted.</li> <li>Copy files (such as BIOS updates) onto the new image (via terminal or drag and drop in Finder).</li> <li>Eject image.</li> <li>Rename file to .img</li> <li>Upload image to PiKVM interface under \"Drive\".</li> <li>Select Drive Mode: <code>Flash</code> and then <code>Connect drive to Server</code>.</li> </ol> <p>You should be able to then mount it locally on the server, or reboot the device to do things like BIOS updates.</p>"},{"location":"msd/#an-alternative-to-making-a-windows-boot-image-that-does-not-require-a-physical-usb-flash-drive","title":"An alternative to making a Windows boot image that does not require a physical usb flash drive","text":"<ul> <li>Physical USB is not needed but external system is mandatory.</li> <li>Create Ventoy image (on Ubuntu x86 machine) (Unaware of a windows version).</li> <li>There is an assumption that you know basic linux to understand that not all dev devices are named exactly like the below</li> </ul> <pre><code># dd if=/dev/zero of=ventoy.img bs=1M count=4700 status=progress\n</code></pre> <ul> <li>This makes a ventoy.img file, I would name this what it is EG: <code>ventoy_win10.img</code></li> <li> <p>At the same time, download Media Creation Tool and select iso</p> </li> <li> <p>On the Ubuntu machine</p> </li> <li>At the time of this, it was 1.0.51, change to latest version</li> </ul> <pre><code># wget https://github.com/ventoy/Ventoy/releases/download/v1.0.51/ventoy-1.0.51-linux.tar.gz\n# tar zxvf ventoy-1.0.51-linux.tar.gz\n# sudo losetup -f ventoy.img\n# sudo losetup -l | grep ventoy (To locate which loop device was used)\n# sudo sh ~/ventoy-1.0.51/Ventoy2Disk.sh -i /dev/loopXX (This will make a loopXXp1 and a loopXXp2 and will format both partitions\n# cd /media/XXX (Usually your login)\n# mkdir ventoy\n# sudo mount /dev/loopXXp1 /media/XXX/ventoy\n</code></pre> <ul> <li>Either cp/scp over the .iso you downloaded from the Media tool or use a NFS mount</li> </ul> <pre><code>sudo cp windows.iso /media/XXX/ventoy\nsudo umount /dev/loopXX \n# This is going to be different for everyone, please choose the same one you mounted earlier\nsudo losetup -d /dev/loopXX \n# This may or may not work for everyone, if it doesnt work, skip and move forward#\n</code></pre> <p>ssh into the Ubuntu system (Or whatever OS you are using)</p> <ul> <li>On PiKVM</li> </ul> <pre><code># cd /var/lib/kvmd/msd\n# mount -o remount,rw .\n</code></pre> <ul> <li>On Ubuntu</li> </ul> <pre><code># scp ventoy.img root@pikvm:/var/lib/kvmd/msd\n</code></pre> <ul> <li>On PiKVM</li> </ul> <pre><code># touch /var/lib/kvmd/msd/.__ventoy.img.complete\n</code></pre> <ul> <li>Mount <code>ventoy.img</code> as normal flash and select the PiKVM boot device, it should popup with the VenToy logo with the window.iso as a selection </li> </ul>"},{"location":"multiport/","title":"Multiport KVM-over-IP","text":""},{"location":"multiport/#multiport-kvm-over-ip","title":"Multiport KVM over IP","text":"<p>There are many ways to do this, but the best and most documented one right now is to use the ezCoo KVM switch.</p> <p>Also, PiKVM can be connected to a multi-port HDMI/USB switch and the switch's buttons can be connected via optocouplers to the Pi's GPIO to switch channels.</p> <p>If your KVM switches channels using keyboard shortcuts, there is a chance that it will not be able to work with OTG (v2+ platform, see below), since it does not fully implement the USB stack. In this case, you will have to use an Arduino board to emulate the keyboard &amp; mouse (PiKVM supports this configuration).</p> <p>Warning</p> <p>If you choose AIMOS, be aware that it has a back powering issue that you need to use work arounds for. Limitations are are listed below. Also please be aware that Arduino's will not work with the AIMOS KVM's.</p>"},{"location":"multiport/#list-of-tested-kvms","title":"List of tested KVMs","text":"<p>Here the status is:</p> <ul> <li>\u2714 - Everything is working as expected. There may be some subtleties.</li> <li>\u2639 - Not everything works. Additional work is needed for some functions to work, like MSD.</li> <li>\u2718 - The keyboard or mouse does not work at all, the switch loses the image, etc.</li> </ul> Model Status Notes ezCoo EZ-SW41HA-KVMU3L 4x1 switch ezCoo SW41HA HDMI 4x1 switch (legacy) \u2714 Using with PiKVM - 4 Port is the ONLY supported KVM, 2 Port does not work the same and is not supported eccoo EZ-SW41HA-KVMU3P 4x1 switch \u2714 make sure you buy the with hotkey version as that has the control port ezcoo EZ-SW41H21-KVMU3P 8K 4x1 switch \u2714 Does NOT have a control port. MSD Works. Can be managed through key combo (ctrl+ctrl+#) TESmart 8 PORT - HDMI KVM SWITCH \u2714 Use OTG with USB 2.0 Hub only, no hotkey support. Switching available with serial or IP-to-serial interface using fixed IP (/31 peer-to-peer addressing supported). Can be managed via WebUI or CLI tool XH-HK4401 4-port HDMI USB KVM Switch \u2714 Using with PiKVM - USB MSD works, requires the HDMI backpower solutions found below Ali's noname \u2639 Limitations are listed below AIMOS 8-port HDMI USB-C KVM Switch \u2639 Similar to Ali's noname model, available in 4/8port editions, has same HDMI bridge boot problem/solution using a Marmitek 312 UHD HDMI splitter. ONLY supports HotKey switching.  Limitations are are listed below Aten CS1758 8-port PS/2 / USB VGA KVM switch \u2639 Older Aten switches can be had for cheap and can be a viable alternative. Devices are connected via PS/2 so USB media support does not work. The setup relies on a VGA-&gt; HDMI adapter to make the video signal work and there can be issues with unsupported VGA resolutions with some adapters. KVM hotkeys and switching all work and so does mouse and keyboard. <p>Limitations:</p> <ul> <li>HDMI backpower solutions:<ul> <li>See here</li> <li>See here - Advanced soldering required</li> <li>This loop capture device</li> <li>v3 HAT v3.3 (Kickstarter model and later) also takes care of the back power issue</li> </ul> </li> <li>MSD workaround (will not work OOB)<ul> <li>RPi4 OTG needs to be in the KB port for mouse and KB funtionality, ZeroW is required and needs to be connected to the HUB port for HK switching and MSD functionality - \u2714KNOWN WORKING\u2714</li> <li>See here - Advanced soldering required - allows use of GPIO menu to change input</li> </ul> </li> </ul>"},{"location":"ocr/","title":"OCR","text":""},{"location":"ocr/#ocr","title":"OCR","text":"<p>This feature allows you to select a screen region, recognize it as text and copy this text to the clipboard. Recognition works locally on your PiKVM and does not use any cloud services. It uses the Tesseract OCR library. Tesseract does not see your image until you explicitly give the recognition command. The evil AI is not watching your screen.</p>"},{"location":"ocr/#language-support","title":"Language support","text":"<p>For any language, you will have to install its support. It is very easy to do this (English language for example): </p><pre><code># rw\n# pacman --assume-installed tessdata -S tesseract-data-eng\n# ro\n</code></pre> <p>List all available languages in the repository: </p><pre><code># pacman -Ss tesseract-data\n</code></pre>"},{"location":"ocr/#disabling-ocr","title":"Disabling OCR","text":"<p>If you want to get rid of this feature completely, you need to delete Tesseract and all its data:</p> <pre><code># rw\n# pacman -R tesseract\n# reboot\n</code></pre>"},{"location":"port_forwarding/","title":"Port forwarding","text":""},{"location":"port_forwarding/#port-forwarding","title":"Port forwarding","text":"<p>If your ISP has provided you with an external IP address for the router, you can configure port forwarding to access PiKVM.</p> <p>Warning</p> <ul> <li>Change passwords before opening access to PiKVM from the outside Internet.</li> <li>It's also a good practice to use only HTTPS (port 443) with a valid certificate (like Let's Encrypt).</li> <li>Additionally, you can use a custom external port number instead of 443, for example 14438 to avoid common port scanners.</li> </ul> <ul> <li>The Web UI runs on port <code>80</code> and <code>443</code>.</li> <li>VNC (if you use it) runs on port <code>5900</code>.</li> </ul> <p>If you don't have an external IP address, then we recommend trying Tailscale VPN.</p>"},{"location":"prometheus/","title":"Prometheus monitoring","text":""},{"location":"prometheus/#prometheus-metrics","title":"Prometheus metrics","text":"<p>Prometheus is one of the popular monitoring systems. It pulls service's endpoint to get metrics in a simple text format. PiKVM has the ability to export some information to this system such as the server's ATX state, Pi's temperature, GPIO state and some other things.</p>"},{"location":"prometheus/#configure-prometheus","title":"Configure Prometheus","text":"<p>To enable Prometheus getting metrics from pikvm following config could be used:</p> <pre><code>scrape_configs:\n- job_name: \"pikvm\"\nmetrics_path: \"/api/export/prometheus/metrics\"\nbasic_auth:\nusername: admin\npassword: admin\nscheme: https\nstatic_configs:\n- targets: [\"pikvm\"]\ntls_config:\ninsecure_skip_verify: true # For self-signed certificate\n</code></pre>"},{"location":"prometheus/#output-example","title":"Output example","text":"<p>This example includes the GPIO from the PiKVM's test config.</p> <pre><code>$ curl -k -HX-KVMD-User:admin -HX-KVMD-Passwd:admin https://pikvm/api/export/prometheus/metrics\n\n# TYPE pikvm_atx_enabled gauge\npikvm_atx_enabled 1\n\n# TYPE pikvm_atx_power gauge\npikvm_atx_power 0\n\n# TYPE pikvm_gpio_input_online_led1 gauge\npikvm_gpio_input_online_led1 0\n\n# TYPE pikvm_gpio_input_state_led1 gauge\npikvm_gpio_input_state_led1 0\n\n# TYPE pikvm_gpio_input_online_led2 gauge\npikvm_gpio_input_online_led2 0\n\n# TYPE pikvm_gpio_input_state_led2 gauge\npikvm_gpio_input_state_led2 0\n\n# TYPE pikvm_gpio_output_online_button1 gauge\npikvm_gpio_output_online_button1 0\n\n# TYPE pikvm_gpio_output_state_button1 gauge\npikvm_gpio_output_state_button1 0\n\n# TYPE pikvm_gpio_output_online_button2 gauge\npikvm_gpio_output_online_button2 0\n\n# TYPE pikvm_gpio_output_state_button2 gauge\npikvm_gpio_output_state_button2 0\n\n# TYPE pikvm_gpio_output_online_relay1 gauge\npikvm_gpio_output_online_relay1 0\n\n# TYPE pikvm_gpio_output_state_relay1 gauge\npikvm_gpio_output_state_relay1 0\n\n# TYPE pikvm_gpio_output_online_relay2 gauge\npikvm_gpio_output_online_relay2 0\n\n# TYPE pikvm_gpio_output_state_relay2 gauge\npikvm_gpio_output_state_relay2 0\n\n# TYPE pikvm_hw_temp_cpu gauge\npikvm_hw_temp_cpu 36.511\n\n# TYPE pikvm_hw_temp_gpu gauge\npikvm_hw_temp_gpu 35.0\n\n# TYPE pikvm_hw_throttling_freq_capped_now gauge\npikvm_hw_throttling_freq_capped_now 0\n\n# TYPE pikvm_hw_throttling_freq_capped_past gauge\npikvm_hw_throttling_freq_capped_past 0\n\n# TYPE pikvm_hw_throttling_throttled_now gauge\npikvm_hw_throttling_throttled_now 0\n\n# TYPE pikvm_hw_throttling_throttled_past gauge\npikvm_hw_throttling_throttled_past 0\n\n# TYPE pikvm_hw_throttling_undervoltage_now gauge\npikvm_hw_throttling_undervoltage_now 0\n\n# TYPE pikvm_hw_throttling_undervoltage_past gauge\npikvm_hw_throttling_undervoltage_past 0\n\n# TYPE pikvm_hw_throttling_raw_flags gauge\npikvm_hw_throttling_raw_flags 0\n* Connection #0 to host localhost left intact\n</code></pre>"},{"location":"pst/","title":"Persistent storage","text":""},{"location":"pst/#persistent-storage","title":"Persistent storage","text":"<p>Note</p> <p>This feature is available on images newer than 2022.06.20</p> <p>Sometimes advanced use of PiKVM requires storing some data on disk like API keys, config files, or something like that. For example, you want to have a script that will update SSL certificates once a week. However, the root file system is in a read-only state and does not involve remounting automatically by user scripts.</p> <p>To solve this problem, new versions of PiKVM have a small 256MiB storage partition that can be used to store that data. A special <code>kvmd-pst</code> daemon makes sure that this partition is mounted in read-only all the time, and remounts it to RW only when some user script requires it. This also solves the problems of simultaneous access, so the RW mode will be keeped as long as at least one client is working with the storage.</p>"},{"location":"pst/#usage","title":"Usage","text":"<p>Below is an example of a script <code>/root/test.sh</code> that wants to save a certain file in PST:</p> <pre><code>#!/bin/bash\necho `date` + $@ &gt; $KVMD_PST_DATA/foo\ncat $KVMD_PST_DATA/foo\n</code></pre> <p>To run it use: </p><pre><code># kvmd-pstrun -- /root/test.sh --some --script --args\n--    INFO -- Opening PST session ...\n--    INFO -- PST write is allowed: /var/lib/kvmd/pst/data\n--    INFO -- Running the process ...\nMon Jun 20 04:23:14 MSK 2022 + --some --script --args\n--    INFO -- Process finished: returncode=0\n</code></pre> <p>So, what's going on here:</p> <ol> <li> <p><code>kvmd-pstrun</code> connects to the <code>kvmd-pst</code> daemon, which manages the mounting of the storage.</p> </li> <li> <p>If everything is fine, the daemon will remount the storage to RW mode and report the data root to <code>kvmd-pstrun</code>.</p> </li> <li> <p><code>kvmd-pstrun</code> runs the script and pass the data root path using the environment variable <code>KVMD_PST_DATA</code> (<code>/var/lib/kvmd/pst/data</code>).</p> </li> <li> <p>If the <code>kvmd-pst</code> daemon stops or any other daemon error occurs, the script will be killed.</p> </li> <li> <p>After the script is finished, the daemon will remount the storage to RO mode.</p> </li> </ol> <p>To be able to write to the storage, the user must be a member of <code>kvmd-pst</code> group, or have to be <code>root</code>.</p> <p>The return code will be equal to the script code if it was run, or 1 if a remount error occurred.</p>"},{"location":"tailscale/","title":"Tailscale VPN","text":""},{"location":"tailscale/#tailscale-vpn","title":"Tailscale VPN","text":"<p>Tailscale can be used to access PiKVM on the internal network. This is a convenient and free (for private use) tool for organizing a small VPN network. This document is provided as an example for accessing your pikvm over the inet but you can also use zerotier or remote.it. Basic support like whats shown below is provided as an example, any other setting or functionality needs to be redirected to the appropriate community.</p>"},{"location":"tailscale/#installation","title":"Installation","text":""},{"location":"tailscale/#on-the-pikvm-side","title":"On the PiKVM side","text":"<ol> <li> <p>Use these commands:</p> <pre><code># rw\n# pacman -Syu tailscale-pikvm\n# systemctl enable --now tailscaled\n# tailscale up\n</code></pre> </li> <li> <p>Follow the link to authorize this installation.</p> </li> <li> <p>After success, perform soft reboot using <code>reboot</code> command to make sure that everything will work correctly.</p> </li> <li> <p>Perform command <code>ip addr show tailscale0</code> to view the Tailscale IP address.</p> </li> </ol>"},{"location":"tailscale/#for-each-device-you-wish-to-access-pikvm","title":"For each device you wish to access pikvm","text":"<ul> <li>Download and install tailscale for your OS to the system you are using, not to the system you want to control.</li> <li>Check the admin page to view your VPN network.</li> <li>Follow the URL in the web browser: <code>https://&lt;tailscale_kvm_ip&gt;</code> and you will see PiKVM web interface.</li> </ul> Note <ul> <li>BASIC troubleshooting in case this fails in some way: Uninstall tailscale, remove these dirs /var/lib/tailscale /var/cache/tailscale and reinstall</li> </ul> <pre><code># pacman -Rscnd tailscale\n# rm -rf /var/lib/tailscale /var/cache/tailscale\n# reboot\n</code></pre> <ul> <li>Follow the above instructions to reinstall</li> </ul>"},{"location":"tesmart/","title":"TESMART managed multiport KVM switch","text":""},{"location":"tesmart/#tesmart-managed-multiport-kvm-switch","title":"TESMART managed multiport KVM switch","text":"<p>The TESMART managed switch can be controlled by PiKVM to allow it to connect to multiple hosts. A typical scenario is a single PiKVM device which can control and switch between multiple hosts or servers using the TESMART switch. UI elements can be added to the GPIO dropdown to allow switching between hosts from the PiKVM webpage. The instructions here were tested with the TESMART HKS1601A10 HDMI 16x1 switch. This should work with any of the other TESMART variants which have a LAN port - there is both a 8x1 and 4x1 variant.  This was tested with an RPI4, but as this is executed over a network protocol, this should with almost anything.</p>"},{"location":"tesmart/#connections","title":"Connections","text":"<p>From a high level, the TESMART switch uses standard connections to the host machines (USB-A to USB-B and HDMI). The Raspberry Pi OTG connector (the one coming from the USB-C port on a Pi 4 via the custom splitter cable or device) should be connected to one of the USB 2 output ports on the TESMART switch (not the keyboard/mouse port). Based on your specific devices, and to get boot images to mount, you may need to connect this through a USB 2 hub.</p> <ol> <li> <p>Connect the USB-A cable from the Raspberry Pi OTG port to one of the TESMART switch USB 2 output ports on the back of the switch (not the keyboard/mouse ports).</p> </li> <li> <p>Connect the HDMI out from the TESMART switch to the Raspberry Pi CSI-2 to HMDI input.</p> </li> <li> <p>Connect the LAN port on the front of the switch using standard ethernet cable into one of your network switches.</p> </li> <li> <p>Connect host USB and HDMI cables from the TESMART switch to the machines to be managed per the switch instructions.</p> </li> </ol> <p>Warning</p> <p>There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi CSI2-HDMI encoder. These limitations apply equally when using the TESMART KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the TESMART switch before powering the hosts on.</p>"},{"location":"tesmart/#setting-the-ip-address-of-the-tesmart-switch","title":"Setting the IP Address of the TESMART switch","text":"<p>In some ways, this is the most complex part of this. The default IP address of the TESMART switch is 192.168.1.10. If that happens to work with your IP addressing scheme and current set of addresses, then you may be all set. This IP address is not configurable via DHCP or other standard mechanisms. The only way to change it is with a Windows utility available on the TESMART Downloads Page.</p> <p>If you need to change it, you will first need to connect to the switch with a Windows machine, most easily directly through an ethernet cord, with your Windows laptop (or VM) up and assigned to a fixed IP address, such as 192.168.1.5. Once you've launched the utility you will see this screen:</p> <p></p> <p>On this screen, ensure you are on the \"General\" tab. Click the radio button for \"Network control\". Change the IP address to the default for the switch (may already be this -- 192.168.1.10). Press the \"Connect\" button. Should make the status light go green, as well as the selected port.  If you do not get a connection here, you cannot proceed to change the IP address.  To change the IP address, change to the \"Settings\" tab at the top. You will then see this screen:</p> <p></p> <p>On this screen, change to your desired IP address, gateway, mask, and port. Then press apply. Watch the box on the right to see if it applied OK. Press Query again to double-check. The actual IP address will not be changed until you power off/power on the switch. Make sure you have these settings correct, because if you get them wrong you would have to connect over RS232/serial and not the network.</p> <p>There may be alternatives other than changing the IP address in this manner if you don't have access to a Windows machine or if this address doesn't work for you. See this README for other options (Images and concepts from the bash file were borrowed for creation of this plugin).  This also contains a summary of the protocol, which is also available on the TESMART downloads page.</p>"},{"location":"tesmart/#adding-ui-elements-to-control-the-kvm-switch","title":"Adding UI elements to control the KVM switch","text":"<p>The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected. The instructions below will make these available in the PiKVM UI after clicking the \"Switches\" menu button in the KVM view.</p> <ol> <li> <p>Enable read-write mode on the SD card via <code>rw</code></p> </li> <li> <p>Edit the <code>/etc/kvmd/override.yaml</code> file and include the following:</p> <pre><code>kvmd:\ngpio:\ndrivers:\ntes:\ntype: tesmart\nhost: 10.10.1.10\nport: 5000\nscheme:\nserver0_led:\ndriver: tes\npin: 0\nmode: input\nserver0_switch:\ndriver: tes\npin: 0\nmode: output\nswitch: false    server1_led:\ndriver: tes\npin: 1\nmode: input\nserver1_switch:\ndriver: tes\npin: 1\nmode: output\nswitch: false    server2_led:\ndriver: tes\npin: 2\nmode: input\nserver2_switch:\ndriver: tes\npin: 2\nmode: output\nswitch: false    server3_led:\ndriver: tes\npin: 3\nmode: input\nserver3_switch:\ndriver: tes\npin: 3\nmode: output\nswitch: false    view:\ntable:\n- [\"TESMART Switch\"]\n- []\n- [\"#Server 1\", server0_led, server0_switch|Switch]\n- [\"#Server 2\", server1_led, server1_switch|Switch]\n- [\"#Server 3\", server2_led, server2_switch|Switch]\n- [\"#Server 4\", server3_led, server3_switch|Switch]\n</code></pre> </li> <li> <p>Return to read-only mode for the sd card via <code>ro</code></p> </li> <li> <p>Restart the <code>kvmd</code> service: <code>systemctl restart kvmd</code></p> </li> </ol>"},{"location":"tesmart/#switching-between-hosts-in-the-ui","title":"Switching between hosts in the UI","text":"<p>To switch between hosts, enter the KVM UI and click the \"Switches\" menu. You should see your inputs, one of which will have a green circle indicating it is currently selected. Click the other inputs to change the selected host.</p>"},{"location":"usb_ethernet/","title":"Ethernet-over-USB","text":""},{"location":"usb_ethernet/#ethernet-over-usb-network","title":"Ethernet-over-USB network","text":""},{"location":"usb_ethernet/#basic-configuration","title":"Basic configuration","text":"<p>Specifically to V2+. When combined with configuring a DNS server, FTP, or SMB (for example), this is a powerful way to extend the capabilities of PiKVM.</p> USB limitations <p>TL;DR: By default, you can add only one additional device to choose from, such as USB Ethernet, or USB Serial, or an extra Mass Storage Drive.</p> <p>There is a hardware limit on the number of devices that can be emulated at the same time. Each USB device uses so-called endpoints to communicate with the host. Depending on the type, the device consumes a different number of endpoints, while their total number is limited by the capabilities of the chip, for Raspberry Pi it is 8.</p> <p>It is quite difficult to calculate the number of endpoints used, but in the case of PiKVM, you can focus on the following numbers:</p> Device Endpoints Keyboard, mouse 1 for each Mass Storage Drive 2 for each USB Ethernet, USB Serial 3 for each <p>V2 and V3 emulates one mouse by default, V4 emulates two mouses. Thus, V2 and V3 use 4 endpoints, and V4 uses 5 by default.</p> <p>Creating an axtra Mass Storage Drive consumes additional endpoints, as well as USB Serial and USB Ethernet, so only a limited number of devices can be selected for the final configuration, for example, one USB Ethernet.</p> <p>If you need something more non-standard, you can disable the regular Mass Storage Drive and the additional mouse (on V4) to free up some extra endpoints.</p> <p>The <code>kvmd-otg</code> service is responsible for setting up USB emulation. If the endpoint limit is exceeded, the service will not be able to start and no emulated USB device will work.</p> <p>In the log it looks something like this:</p> <pre><code># journalctl -u kvmd-otg\n...\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- ===== Preparing complete =====\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- Enabling the gadget ...\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- WRITE --- /sys/kernel/config/usb_gadget/kvmd/UDC\nkvmd-otg[382]: OSError: [Errno 524] Unknown error 524\nkvmd-otg[382]: During handling of the above exception, another exception occurred:\nkvmd-otg[382]: Traceback (most recent call last):\nkvmd-otg[382]:   File \"/usr/bin/kvmd-otg\", line 9, in &lt;module&gt;\nkvmd-otg[382]:     main()\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 348, in main\nkvmd-otg[382]:     options.cmd(config)\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 278, in _cmd_start\nkvmd-otg[382]:     _write(join(gadget_path, \"UDC\"), udc)\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 83, in _write\nkvmd-otg[382]:     with open(path, \"w\") as file:\nkvmd-otg[382]: OSError: [Errno 524] Unknown error 524\nsystemd[1]: kvmd-otg.service: Main process exited, code=exited, status=1/FAILURE\nsystemd[1]: kvmd-otg.service: Failed with result 'exit-code'.\nsystemd[1]: Failed to start PiKVM - OTG setup.\n</code></pre> <p>In this case, you need to disable some of the previously enabled devices and restart PiKVM.</p> <ol> <li> <p>Edit <code>/etc/kvmd/override.yaml</code> and add these lines:</p> <pre><code>otg:\ndevices:\nethernet:\nenabled: true\ndriver: ecm\nhost_mac: 48:6f:73:74:50:43\nkvm_mac: 42:61:64:55:53:42\n</code></pre> <p>The <code>host_mac</code> address will be used on the server's network interface. The <code>kvm_mac</code> means the address that will be assigned to the local interface on the PiKVM. The KVM interface will be called <code>usb0</code>network interface. If the <code>host_mac</code> or <code>kvm_mac</code> is not specified, a random value will be used. The <code>driver</code> parameter means the protocol that will be used for the USB network. The default value is <code>ecm</code> so it can be passed it this example. Other possible values are <code>eem</code>, <code>ncm</code>, <code>rndis</code> and <code>rndis5</code>.</p> <p>Driver compatibility:</p> Driver Operating System ecm Linux eem Linux rndis5 Windows XP to Windows 71Linux &gt; 2.6.13 rndis Windows 7 and later2Linux &gt; 2.6.13 ncm Windows 10 and laterLinux &gt; 2.6.37 <p>1: Manual driver installation is required. Download RNDIS 5 Windows 2: Automatic driver installation since kvmd-3.53</p> </li> <li> <p>To automatically configure the USB network on the server recommended using the service <code>kvmd-otgnet</code>. It configures the firewall, assigns an address to the local PiKVM interface <code>usb0</code> and starts DHCP so the managed server can get the IPv4 address. By default, the address <code>169.254.0.1/28</code> to interface <code>usb0</code> will be assigned. One of the other addresses from the network <code>169.254.0.0./28</code> will be assigned to the server when it requests it via DHCP. For security reasons, all incoming connections from the server to the PiKVM side are blocked (except for ICMP and UDP port 67 which is used for DHCP). If you want to allow access from the server to the PiKVM interface, then you need to add ports 80 and 443 to the whitelist using <code>/etc/kvmd/override.yaml</code> file like this:</p> <pre><code>otgnet:\nfirewall:\nallow_tcp: [80, 443]\n</code></pre> <p>To view other available configuration parameters, use the command <code>kvmd -m</code>.</p> </li> <li> <p>To enable the service, use the command <code>systemctl enable kvmd-otgnet</code>.</p> </li> <li> <p>Perform <code>reboot</code>.</p> </li> </ol>"},{"location":"usb_ethernet/#routing-via-pikvm","title":"Routing via PiKVM","text":"<p>By default, <code>kvmd-otgnet</code> will configure network connection between PiKVM and the server host only. The server host will not be able to reach other hosts beyond PiKVM. If the full network access is required from the server host through the USB-Ethernet feature (access all hosts PiKVM can access), additional settings are needed in <code>/etc/kvmd/override.yaml</code>.</p> <ol> <li> <p>Run <code>echo \"net.ipv4.ip_forward = 1\" &gt; /etc/sysctl.d/99-kvmd-extra.conf</code>.</p> </li> <li> <p>Add network interface to forward requests to (default gateway) by adding a line <code>forward_iface: &lt;interface name&gt;</code> under <code>firewall:</code>. Typically it would be <code>eth0</code> if the built-in ethernet port is used::</p> <pre><code>otgnet:\nfirewall:\nforward_iface: eth0\n</code></pre> </li> <li> <p>Add DNS server to provide host name resolution service. For example, adding <code>8.8.8.8</code> as DNS server requires addition of <code>dnsmasq</code> dhcp options. This can be done by adding following lines to <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>otgnet:\ncommands:\npost_start_cmd_append:\n- \"--dhcp-option=6,8.8.8.8\"\n</code></pre> </li> <li> <p>Combining above two together::</p> <p></p><pre><code>otgnet:\nfirewall:\nforward_iface: eth0\ncommands:\npost_start_cmd_append:\n- \"--dhcp-option=6,8.8.8.8\"\n</code></pre> 5. To enable internet access for the server host, add the following to the otgnet configuration:: <p></p><pre><code> otgnet:\niface:\nnet: 10.65.0.0/28\n</code></pre> The 'net' parameter defines the network address range of the usb0 network. The server host will automatically receive an IP address within this network including the DNS servers defined under 'post_start_cmd_append'. Note: This network should not be same as the network PiKVM is connected to. </li> <li> <p>Don't forget to <code>reboot</code>.</p> </li> </ol> An example of what the config would look like for a server host that can access PiKVM and has internet access: <pre><code>otgnet:\n    firewall:\n        allow_tcp: [80, 443]\n        forward_iface: wlan0\n    commands:\n        post_start_cmd_append:\n            - \"--dhcp-option=6,1.1.1.1,1.0.0.1\"\n    iface:\n        ip_cmd:\n            - /usr/bin/ip\n        net: 10.65.0.0/28\n</code></pre>"},{"location":"usb_ethernet/#working-with-windows-computers","title":"Working with Windows Computers","text":"<p>This has been proven to work with Windows:</p> <ol> <li> <p>Set the driver type to rndis (see above).</p> </li> <li> <p>Download this driver on the Windows machine and unzip it somewhere.</p> </li> <li> <p>Open the devices manager: </p> </li> <li> <p>Select Properties of the Composite KVM Device: </p> </li> <li> <p>Select the RNDIS Device and click properties: </p> </li> <li> <p>Switch to the Driver tab and then click Update driver.</p> </li> <li> <p>Click Browse my computer for driver software: </p> </li> <li> <p>Click Let me pick from a list of available drivers on my Computer: </p> </li> <li> <p>From the list of available hardware types, scroll down and select Network adapters, then click Next: </p> </li> <li> <p>Click Have disk: </p> </li> <li> <p>Click Browse, navigate to the folder where you've stored the driver and select the RNDIS.inf, press Open and then OK: </p> </li> <li> <p>Select Acer Netchip RNDIS/Ethernet Gadget and click Next: </p> </li> <li> <p>Dismiss the warning about non-compatible drivers by clicking Yes: </p> </li> <li> <p>You're done - the device should now be recognized: </p> </li> <li> <p>Verify the card is working by pinging your PiKVM in a console: <code>ping 169.254.0.1</code>: </p> </li> </ol>"},{"location":"usb_serial/","title":"Serial-over-USB","text":""},{"location":"usb_serial/#serial-over-usb-connection","title":"Serial-over-USB connection","text":"<p>Specifically to V2+. This can be used for terminal access from the managed server to the PiKVM, or for any other purpose that requires a serial connection. In the last case, you only need to perform step 1 and reboot.</p> USB limitations <p>TL;DR: By default, you can add only one additional device to choose from, such as USB Ethernet, or USB Serial, or an extra Mass Storage Drive.</p> <p>There is a hardware limit on the number of devices that can be emulated at the same time. Each USB device uses so-called endpoints to communicate with the host. Depending on the type, the device consumes a different number of endpoints, while their total number is limited by the capabilities of the chip, for Raspberry Pi it is 8.</p> <p>It is quite difficult to calculate the number of endpoints used, but in the case of PiKVM, you can focus on the following numbers:</p> Device Endpoints Keyboard, mouse 1 for each Mass Storage Drive 2 for each USB Ethernet, USB Serial 3 for each <p>V2 and V3 emulates one mouse by default, V4 emulates two mouses. Thus, V2 and V3 use 4 endpoints, and V4 uses 5 by default.</p> <p>Creating an axtra Mass Storage Drive consumes additional endpoints, as well as USB Serial and USB Ethernet, so only a limited number of devices can be selected for the final configuration, for example, one USB Ethernet.</p> <p>If you need something more non-standard, you can disable the regular Mass Storage Drive and the additional mouse (on V4) to free up some extra endpoints.</p> <p>The <code>kvmd-otg</code> service is responsible for setting up USB emulation. If the endpoint limit is exceeded, the service will not be able to start and no emulated USB device will work.</p> <p>In the log it looks something like this:</p> <pre><code># journalctl -u kvmd-otg\n...\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- ===== Preparing complete =====\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- Enabling the gadget ...\nkvmd-otg[382]: kvmd.apps.otg                     INFO --- WRITE --- /sys/kernel/config/usb_gadget/kvmd/UDC\nkvmd-otg[382]: OSError: [Errno 524] Unknown error 524\nkvmd-otg[382]: During handling of the above exception, another exception occurred:\nkvmd-otg[382]: Traceback (most recent call last):\nkvmd-otg[382]:   File \"/usr/bin/kvmd-otg\", line 9, in &lt;module&gt;\nkvmd-otg[382]:     main()\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 348, in main\nkvmd-otg[382]:     options.cmd(config)\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 278, in _cmd_start\nkvmd-otg[382]:     _write(join(gadget_path, \"UDC\"), udc)\nkvmd-otg[382]:   File \"/usr/lib/python3.10/site-packages/kvmd/apps/otg/__init__.py\", line 83, in _write\nkvmd-otg[382]:     with open(path, \"w\") as file:\nkvmd-otg[382]: OSError: [Errno 524] Unknown error 524\nsystemd[1]: kvmd-otg.service: Main process exited, code=exited, status=1/FAILURE\nsystemd[1]: kvmd-otg.service: Failed with result 'exit-code'.\nsystemd[1]: Failed to start PiKVM - OTG setup.\n</code></pre> <p>In this case, you need to disable some of the previously enabled devices and restart PiKVM.</p> <ol> <li> <p>Edit <code>/etc/kvmd/override.yaml</code> and add these lines:</p> <pre><code>otg:\ndevices:\nserial:\nenabled: true\n</code></pre> </li> <li> <p>Run the following command:</p> <pre><code># echo ttyGS0 &gt;&gt; /etc/securetty\n</code></pre> </li> <li> <p>Create the directory <code>/etc/systemd/system/getty@ttyGS0.service.d</code> and add a file file named <code>override.conf</code> into it. Afterwards edit the file and copy this into it:</p> <pre><code>[Service]\nTTYReset=no\nTTYVHangup=no\nTTYVTDisallocate=no\n</code></pre> </li> <li> <p>Run these comands:</p> <pre><code># systemctl enable getty@ttyGS0.service\n# reboot\n</code></pre> </li> <li> <p>Once PiKVM is rebooted you will have access to a virtual serial port on the server that the USB is connected to. Use mingetty, screen, putty, or something like this to access the kvm from the server. The port is called <code>/dev/ttyAMA0</code>.</p> </li> </ol>"},{"location":"v3/","title":"PiKVM V3 HAT guide","text":""},{"location":"v3/#pikvm-v3-hat","title":"PiKVM V3 HAT","text":""},{"location":"v3/#installation-requirements","title":"Installation requirements","text":"If you have an assembly kit, you will need the following things <ul> <li>Raspberry Pi 4 with 1Gb RAM or more.</li> <li>Heat sinks (Optional)</li> <li>MicroSD card (at least 16Gb, class 10 recommended).</li> <li>USB-C to USB-A cable.</li> <li>HDMI cable.</li> <li>Straight Ethernet cable (for the ATX board connection).</li> <li>Power supply unit (5.1V 3A USB-C, recommended by the Raspberry Pi).</li> </ul> <p>Before assembling</p> <ul> <li>Please review the back of the box. All parts are required before the HAT is fully functional.</li> <li>The USB-C bridge is located in with the ATX end which includes a pink foam spacer.</li> <li>Please assemble the HAT onto the RPi and test all of the parts before installing in the case, it's easier to install in the case than to dissasemble it.</li> <li>If going from a V2 to a V3, the splitter is no longer needed.</li> </ul> For pre-assembled V3 <ul> <li>If going from a V2 to a V3, the splitter is built in and is no longer needed.</li> </ul>"},{"location":"v3/#basic-setup","title":"Basic setup","text":"<p>If you have a kit without a metal case, you can use our free 3D printing case drawing: V3.3 for the Kickstarter/Store model, V3.2 for the pre-release.</p> <ol> <li> <p>Flash the memory card.. Please use the V3 image, V2 image is not compatible.</p> </li> <li> <p>Build PiKVM according to the video instruction or review the illustrated instructions:</p> Video Guide: Metal case step by step <p>NOTE: OLED will not light up till step 5 is performed, video was performed after it was already configured, heat sinks NOT included. </p> Video Guide: Step by step with HAT device with or without the 3D-printed case <p></p> <p>OLED glass can crack if force is used to install it, please handle with care and rock back and forth on the pins side to install.</p> </li> <li> <p>Connect PiKVM to the computer according to the diagram below:</p> Back side Front side <ul> <li> <p>HDMI input and USB emulation port must be connected to the computer. Optionally, the ATX port can be connected to control the power. There should be no USB hub between PiKVM and the computer, as some UEFI/BIOS cannot detect them at the boot stage. On the HDMI the HAT, like the CSI bridge, supports 1080p50Hz or 720p60Hz or lower.</p> </li> <li> <p>Connect Ethernet to the network and USB power to the Raspberry Pi power supply.</p> </li> </ul> </li> <li> <p>Carefully read the \"First steps\" guide - how to find a device on the network, how to log in there, change passwords, and so on. Follow the steps described there and come back to this page.</p> </li> <li> If your kit includes the OLED display and/or the fan, you'll need to turn them on (this is only needed for the older V3 image for the HAT, in the box image everything is enabled by default) <p>Log in to PiKVM and run these commands: </p><pre><code># rw\n# systemctl enable --now kvmd-oled kvmd-oled-reboot kvmd-oled-shutdown\n# systemctl enable --now kvmd-fan\n# ro\n</code></pre> </li> <li> Using Fahrenheit instead of Celsius on the OLED <p></p><pre><code># mkdir -p /etc/systemd/system/kvmd-oled.service.d\n</code></pre> Create file <code>touch or nano /etc/systemd/system/kvmd-oled.service.d/override.conf</code>: <pre><code>[Service]\nExecStart=\nExecStart=/usr/bin/kvmd-oled --clear-on-exit --fahrenheit\n</code></pre> And run <code>systemctl restart kvmd-oled</code>. In some cases, if you still do not see Fahrenheit being displayed, reboot the device.  </li> <li> <p>Just reminding again: CHANGE THE PASSWORDS! :)</p> <p>How to do this was written in the \"First steps\" guide</p> </li> <li> <p>Try to manage the computer using PiKVM with the Web Interface. Make sure that you get an image and both keyboard and mouse are working. If something doesn't work, check out our FAQ (it's really useful). If nothing helped, you can get support in our Discord chat.</p> </li> <li> Check the HDMI backpowering problem. ONLY applicable under specific circumstances. NOT getting NO SIGNAL. <p>Try restarting PiKVM using the <code>reboot</code> command executed in the terminal. If PiKVM hangs during boot (you can't get the Web Interface for a long time), then you are faced with this rare problem. Don't worry, it's easy to fix. Turn off the PiKVM, disconnect all cables from it, take a close look at the diagram of its ports and jumpers, and remove jumper #14 (it is to the right of the CSI connector). Then you can connect and power up PiKVM again. Now everything will be fine. If you are interested in the technical background, it is described here. Also, just for information: not a single case of negative consequences from the removal of the jumper has been recorded.</p> </li> <li> <p>IO ports and other things</p> <p>Before using GPIO pins to control a relay, KVM switch, or anything else, be sure to check the HAT pinout. Many ports are busy with internal functions. Before using them for your own use, you must disable them, otherwise you may damage the device.</p> </li> <li> <p>You can also try the experimental audio forwarding.</p> </li> <li> <p>Explore the features of PiKVM using the site's table of contents and have fun!</p> </li> </ol>"},{"location":"v3/#atx-connection","title":"ATX connection","text":"<p>See here.</p>"},{"location":"v3/#io-ports-and-jumpers","title":"IO ports and jumpers","text":"See the diagram <ol> <li>ATX controller interface (power on/off, reboot control, PWR and HDD ACT LEDs).</li> <li>HDMI reset jumper. Connects GPIO 17 and RESET pin to HDMI capture chip. Currently not used, don't touch it.</li> <li>SPI and GPIO for the custom extension boards.</li> <li>Audio capture jumpers. Connects I2S pins 18, 19, 20 to HDMI capture chip.</li> <li>UART access jumpers. Connects GPIO 14 and 15 to the RJ-45 and USB console ports.</li> <li>Serial console port (default: /dev/ttyAMA0, RS232 input, outputs +6V/-6V, for the Raspberry Pi or server console access, use the Cisco/Mikrotik-style cable).</li> <li>USB-C console port (shared with #6 above, takes priority over RJ45).</li> <li>Power and activity LEDs. On the left of the LEDs the watchdog jumper is located. Don't touch it.</li> <li>USB-C power input.</li> <li>I2C display connector.</li> <li>Alternate +5V power input/output header pins.</li> <li>RTC clock supercapacitor (rechargeable).</li> <li>FAN connector - PWM controlled.</li> <li>CSI-2 interface and HDMI backpowering jumper, see Step 9 of the Basic Setup. Open: (jumper removed) diode will stop current from HDMI input (backpower will be fixed), closed: (jumper connected to both pins) will allow current from HDMI device. </li> <li>Built-in power splitter port.</li> <li>HDMI capture port (max 1080p @ 50Hz) with sound capture support.</li> <li>USB emulation pins for alternative access.</li> <li>USB-C emulation port - this port is doing the emulation of a USB keyboard, mouse, Virtual CD-ROM or USB Flash Drive, USB-Ethernet, USB-Serial port and a lot of other Linux-supported features.</li> <li>1-Wire &amp; Neo-pixel interface (under, advanced user feature).</li> </ol> GPIO pinout <p>Before proceeding, make sure that the mb you are using has normal ATX headers</p> <ul> <li>ATX control</li> <li><code>power led = GPIO 24</code> - Used for reading the host power state.</li> <li><code>hdd led = 22</code> - Same for the HDD activity.</li> <li><code>power switch = 23</code> - Used for pressing the power button of the host.</li> <li><code>reset switch = 27</code> - Same for the reset button.</li> </ul> <p>These pins can't be used for any other purposes even if ATX function is disabled.</p> <ul> <li> <p>I2C bus - <code>GPIO 2, 3</code> - Can be used as I2C ONLY (OLED/RTC).</p> </li> <li> <p>1-Wire [19] - <code>GPIO 4</code> - Also available under ATX RJ-45 port (point [19] on the above) as bi-directional buffered open-drain 5V for regular 1-Wire usage.</p> </li> <li> <p>UART - <code>GPIO 14, 15</code> - Can be used as UART only for the serial console. When jumpers [5] are removed, you can connect to pins 14 and 15 directly using GPIO header. Also you can remove jumper [5] and disable UART console in the <code>/boot/config.txt</code> and <code>/boot/cmdline.txt</code> to use this pins for any purpose. But it's not recommended.</p> </li> <li> <p>Red activity led on the front [8] - <code>GPIO 13</code> - Can be disabled in <code>/boot/config.txt</code> and available on the Neo-pixel port [19].</p> </li> <li> <p>PWM fan controller - <code>GPIO 12</code>. Can be used for custom purposes if the fan disconnected and <code>kvmd-fan</code> service is stopped.</p> </li> <li> <p>I2S HDMI sound - <code>GPIO 18, 19, 20, 21</code>. Can be used for custom purposes if the <code>tc358743-audio</code> overlay in <code>/boot/config.txt</code> is disabled AND jumpers [4] are removed.</p> </li> <li> <p>USB breaker - <code>GPIO 5</code> - Can't be used for any other purposes.</p> </li> </ul>"},{"location":"v3/#known-issues-and-limitations","title":"Known issues and limitations","text":"<ul> <li>The actual frame rate of the image received via HDMI will depend on the network bandwidth, resolution and the load on the Raspberry Pi. This is usually ~24-28 FPS for 1080p over LAN.</li> <li>There may be compatibility issues with some motherboards (such as HP or DELL) which are the same as those that exist with PiKVM V2. Not everything is perfect, but if you have already used PiKVM V2 - our new V3 will work great and please you. If there is no image from the BIOS, you can fine-tune the HDMI settings, but it is possible that the Mass Storage devices will not be available in the BIOS.</li> <li>Pre-release V3.2 board (NOT Kickstarter/Store edition) doesn't have HDMI backpowering workaround jumper.</li> </ul>"},{"location":"v3_illustrated_install_instructions/","title":"Step 1","text":""},{"location":"v3_illustrated_install_instructions/#step-1","title":"Step 1","text":"<p>Remove contents from box.</p>"},{"location":"v3_illustrated_install_instructions/#contents","title":"Contents:","text":"<ul> <li>8x M.2 5x12mm screws for the case</li> <li>4x M.2 5x12mm screws for the fan</li> <li>4x bolts for the fan</li> <li>1x fan (30x30x7mm 5v)</li> <li>1x case top</li> <li>1x case bottom</li> <li>1x OLED display (0.91 IIC 128x32 LCD)</li> <li>2x bottom plastic risers</li> <li>1x plastic top riser</li> <li>1x plastic OLED holder that is also a front riser</li> <li>2x small FCC ribbon cables</li> <li>1x small rubber square that break out to 4x small rubber feet</li> </ul> <p>OLED is sensitive to pressure, do NOT push down on the very thin glass as it will crack thereby making the OLED non-functional</p>"},{"location":"v3_illustrated_install_instructions/#step-2","title":"Step 2","text":"<p>Take bottom part of the case, insert the RPI4 into the bottom case at an angle, you will need to flex the other side ever so slightly to get it to slot in.</p> <p></p> IF you bought heatsink's (sold seperatly), it's advised to install them now before installing the HAT"},{"location":"v3_illustrated_install_instructions/#step-3","title":"Step 3","text":"<p>Insert HAT at the same angle, take care to line up the pins on the Rpi with the HAT pin sleeve, the trick to this is to push the Rpi all of the way to the left then all of the way to the right for proper alignment, do NOT force till the pins are aligned. If properly aligned the pins will match up without issue.</p> <p></p> <p></p> ALTERNATIVE: As an alternative to the above, you can pre assemble the hat+fcc cable onto the RPI4, then insert them into the bottom portion of the case however you will need to flex the sides more whereby creating a bigger gap when fully assembled."},{"location":"v3_illustrated_install_instructions/#step-4","title":"Step 4","text":"<p>There are 2 ways to insert the FCC cable, you can add it when you insert the RPI in Step 2 OR wait till you also have the HAT installed and slide it into the slot.</p> <p></p> The blue stripes on the ends of the cable will ALWAYS face the side that will be used to tighten the FCC to the camera port or have it positioned towards the power - Ignore the smaller FCC cable that plugs into the USB, was phased out during the KS campaign. This image was used as a means of illustrating FCC placement and orientation"},{"location":"v3_illustrated_install_instructions/#step-5","title":"Step 5","text":"<p>Install USB-C bridge.</p> This is packaged with the ATX board <p></p> <p></p> If you do not install this bridge, mouse/kb will not work HAT will still power on without this bridge installed"},{"location":"v3_illustrated_install_instructions/#step-6","title":"Step 6","text":"<p>Turn the bottom of the case upside down, install the 2 bottom plastic risers, it's best to install in a wing formation. Top first by inserting the top screws then slide the bottom part aligning the plastic to the holes then inserting the screws. At this point its OK to tighten the bottom screws. There is no need to use force, just tighten enough to prohibit movement.</p> <p></p>"},{"location":"v3_illustrated_install_instructions/#step-7","title":"Step 7","text":"<p>Take the plastic OLED holder, turn the OLED over where the back side is facing you and insert at an angle so as to create a space between the OLED and holder arm, take a flat head screwdriver (medium normal) and twist it enough so you can clear the electronics on the bottom of the OLED and continue to gently slide in the remaining OLED till its fully inserted.</p> <p></p> <p>Be careful on handling this display, slight pressure will damage the OLED, however in the event that this does happen, replacements are cheap and can be found in most electronic stores or Amazon, look for any IIC (I2C) .91 inch display for Arduino</p>"},{"location":"v3_illustrated_install_instructions/#step-8","title":"Step 8","text":"<p>Insert the OLED holder with the OLED display into the plug by gently rocking it back and forth till it's fully inserted.</p> <p></p>"},{"location":"v3_illustrated_install_instructions/#step-8a","title":"Step 8a","text":"<p>Install plastic spacer.</p> <p></p>"},{"location":"v3_illustrated_install_instructions/#step-9","title":"Step 9","text":"<p>Install the screws and bolts to secure the fan, it does not matter the orientation of the fan, push or pulling air will result in the same behavior, its personal preference.</p> <p></p>"},{"location":"v3_illustrated_install_instructions/#step-10","title":"Step 10","text":"<p>Insert the fan leads and align Red with positive and Black with negative.</p> <p></p> <p>You can damage the fan if installed incorrectly</p>"},{"location":"v3_illustrated_install_instructions/#step-11","title":"Step 11","text":"<p>Install the top of the case to the bottom, use the 4 remaining screws to secure the top.</p> <p></p>"},{"location":"v3_illustrated_install_instructions/#step-12","title":"Step 12","text":"<p>Please follow the V3 guide and First Steps guide to activate your PiKVM.</p>"},{"location":"v4/","title":"PiKVM V4 Mini & Plus guide","text":""},{"location":"v4/#pikvm-v4-mini-plus","title":"PiKVM V4 Mini &amp; Plus","text":"<ul> <li>PiKVM V4 Mini Datasheet PDF</li> <li>PiKVM V4 Plus Datasheet PDF</li> </ul>"},{"location":"v4/#installation-requirements","title":"Installation requirements","text":"<ul> <li>PiKVM V4 Mini or Plus box kit.</li> <li>Any reliable HDMI cable.</li> </ul>"},{"location":"v4/#basic-setup","title":"Basic setup","text":"<ol> <li> <p>Unpack the box and connect the PiKVM according to diagram:</p> Back side Front side <ul> <li> <p>HDMI input (the bottom right on the back side) and OTG port (USB emulation) should be connected to the computer. Optionally, the ATX port can be connected to control the power. There should be no USB hub between PiKVM and the computer, as some UEFI/BIOS cannot detect them at the boot stage.</p> </li> <li> <p>Connect Ethernet (bottom right on the front size) to the network using the cable from the kit. The kit includes two Ethernet cables of different colors: one for the network, the second for ATX. Use whichever one you like best.</p> </li> <li> <p>Use the power supply and turn on PiKVM. The Mini comes with USB-C 5V power supply, and Plus with Barrel 12V. Use the appropriate connector on the front side. Please note that Plus can also work from 5V, in this case, do not connect a 12V power supply and don't create a significant power load on USB (external flash sticks, cameras, and so on).</p> </li> </ul> </li> <li> <p>Wait until PiKVM starts and shows a greeting on the built-in display. Do not turn off the device until it's fully booted for the first time.</p> </li> <li> <p>Carefully read the \"First steps\" guide - how to find a device on the network, how to log in there, change passwords, and so on. Follow the steps described there and come back to this page.</p> </li> <li> Using Fahrenheit instead of Celsius on the OLED <p></p><pre><code># mkdir -p /etc/systemd/system/kvmd-oled.service.d\n</code></pre> Create file <code>touch or nano /etc/systemd/system/kvmd-oled.service.d/override.conf</code>: <pre><code>[Service]\nExecStart=\nExecStart=/usr/bin/kvmd-oled --clear-on-exit --fahrenheit\n</code></pre> And run <code>systemctl restart kvmd-oled</code>. In some cases, if you still do not see Fahrenheit being displayed, reboot the device.  </li> <li> <p>Just reminding again: CHANGE THE PASSWORDS! :)</p> <p>How to do this was written in the \"First steps\" guide</p> </li> <li> <p>Try to manage the computer using PiKVM with the Web Interface. Make sure that you get an image and both keyboard and mouse are working. If something doesn't work, check out our FAQ (it's really useful). If nothing helped, you can get support in our Discord chat.</p> </li> <li> <p>Explore the features of PiKVM using the site's table of contents and have fun!</p> </li> </ol>"},{"location":"v4/#atx-connection","title":"ATX connection","text":"<p>See here.</p>"},{"location":"v4/#known-issues-and-limitations","title":"Known issues and limitations","text":"<ul> <li>The actual frame rate of the image received via HDMI will depend on the network bandwidth, resolution and the load on the Raspberry Pi. This is usually ~24-28 FPS for 1080p over LAN.</li> <li>There may be compatibility issues with some motherboards (such as HP or DELL) which are the same as those that exist with PiKVM V2. Not everything is perfect, but if you have already used PiKVM V2 - our new V4 will work great and please you. If there is no image from the BIOS, you can fine-tune the HDMI settings, but it is possible that the Mass Storage devices will not be available in the BIOS.</li> </ul>"},{"location":"video/","title":"Working with video","text":""},{"location":"video/#working-with-video","title":"Working with video","text":""},{"location":"video/#video-recording","title":"Video recording","text":"<p>Info</p> <p>H.264 is available on Pi 3 and Pi 4. Older boards won't handle it. Best of all this feature only works for HDMI to CSI bridge. For the USB HDMI dongle, there will be a decrease in FPS to 10-15 for 1080p. Work in progress.</p> <ol> <li> <p>Perform full system update to get the latest uStreamer and install ffmpeg:</p> <pre><code># rw\n# pacman -Syu ffmpeg\n</code></pre> </li> <li> <p>For USB dongle only: Add line <code>gpu_mem=256</code> to <code>/boot/config.txt</code>.</p> </li> <li> <p>Perform <code>reboot</code> command.</p> </li> <li> <p>Run <code>rw</code> after the reboot.</p> </li> <li> <p>To record a video, you need to enable the stream (open the web interface or connect via VNC). Then run something like this in the console:</p> <pre><code># rw\n# ustreamer-dump --sink kvmd::ustreamer::h264 --output - | ffmpeg -use_wallclock_as_timestamps 1 -i pipe: -c:v copy test.mp4\n</code></pre> </li> <li> <p>Press <code>Ctrl+C</code> to stop recording. Your video will be in the file <code>test.mp4</code>.</p> </li> <li> <p>After finishing work, do not forget to switch the file system to read-only mode using <code>ro</code> command.</p> </li> </ol>"},{"location":"video/#take-a-screenshot-via-console-on-pikvm","title":"Take a screenshot via console on PiKVM","text":"<p>Note</p> <p>You must have a stream running</p> <pre><code># curl --unix-socket /run/kvmd/ustreamer.sock http://localhost/snapshot -o /tmp/screen.jpg\n</code></pre>"},{"location":"vnc/","title":"Using VNC","text":""},{"location":"vnc/#vnc","title":"VNC","text":"<p>As an alternative to the web interface, you can use VNC with various desktop clients. The main advantage of VNC over the browser is the ability to expand the image to the full screen, as well as complete interception of all keyboard keys. In some cases, VNC will be more responsive than the browser, especially on weak computers.</p> <p>Warning</p> <p>Don't use VNC without X.509 or TLS encryption on untrusted networks! Otherwise your password will be transmitted over the network in plain text. Unfortunately, this is the reality of the VNC protocol.</p> <p>Note</p> <p>VNC and its varients/TeamViewer/RDP to a system uses the target systems framebuffer IE local display, VNC usage for PiKVM accesses the stream, there will still be a 100-200ms latency and cannot be compared with the other software solutions.</p> <ul> <li>NORMAL USAGE: VNC/TM/RDP -&gt; Target system</li> <li>PiKVM USAGE: VNC -&gt; PiKVM (hardware capture, processing) -&gt; Target system</li> </ul>"},{"location":"vnc/#enabling-vnc-on-the-pikvm-side","title":"Enabling VNC on the PiKVM side","text":"<ol> <li> <p>Switch PiKVM filesystem to read-write mode using command <code>rw</code>.</p> </li> <li> <p>Optional: Change client's keyboard layout if you're using an non-US keyboard. To do this edit file <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>vnc:\nkeymap: /usr/share/kvmd/keymaps/ru\n</code></pre> <p>All available keymaps are located in <code>/usr/share/kvmd/keymaps</code>:</p> <p></p> </li> <li> <p>Optional: This step is not nessessory if using TigerVNC as it uses the webgui user:pass. Some VNC clients (for example TightVNC) can't use user/password authentication. In this case you can enable passphrases mode in <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>vnc:\nauth:\nvncauth:\nenabled: true\n</code></pre> <p>To set passphrases edit file <code>/etc/kvmd/vncpasswd</code>.</p> </li> <li> <p>Enable <code>kvmd-vnc</code> daemon. VNC will be available on the port 5900: <code>systemctl enable --now kvmd-vnc</code>.</p> </li> <li> <p>Switch filesystem back to read-only: <code>ro</code>.</p> </li> </ol> <p>Note</p> <p>With enabled 2FA, you will need to add the one-time code to the password without spaces. That is, if the password is <code>foobar</code> and the code is <code>123456</code>, then you need to use <code>foobar123456</code> as the password. Also note that <code>vncauth</code> (step 3) will not work with 2FA.</p>"},{"location":"vnc/#configuring-the-client","title":"Configuring the client","text":"<p>We recommend TigerVNC for a better experience on desktop.</p> <p>If you are using PiKVM V3+ or DIY based on CSI bridge, you can try the latest version (&gt;= 1.13.0) of TigerVNC with H.264 support. It will improve performance and save traffic.</p> <p>H.264 is available in binary builds for Windows, for other OS it needs to be compiled manually (before that, you need to install ffmpeg libraries).</p> <p>Here are our recommended settings for TigerVNC:</p> Compression tab Security tab If your client does not support H.264, choose Tight <p>For iOS and Android the recommended application is bVNC:</p> <ul> <li>Google Play</li> <li>App Store</li> </ul>"},{"location":"vnc/#unsupported-clients","title":"Unsupported clients","text":"<ul> <li>RealVNC - Does not support most widely used open VNC protocol extensions.</li> <li>Remmina - Slightly imperfect algorithms for matching settings with the server, we are working on it.</li> <li>Guacamole - Incorrectly implements vencrypt, no JPEG compression.</li> <li>Vinagre - Incorrectly implements vencrypt, dead.</li> </ul>"},{"location":"webrtc/","title":"H.264 / WebRTC","text":""},{"location":"webrtc/#h264-webrtc","title":"H.264 / WebRTC","text":"<p>Only main browsers are supported: Chrome, Firefox and Safari</p> <p>Only for V3 and other devices based on CSI bridge</p> <p>This is a new alternative video transfer mode available for Raspberry Pi 4 users with an HDMI-CSI bridge (including PiKVM v3 HAT). It uses H.264 encoding instead of MJPEG and provides significantly less traffic consumption.</p> <p>If you use an OS image built after 2021.06.10, this mode will be available by default. If you are upgrading to an older version of the OS, you will need to manually enable the WebRTC gateway:</p> <pre><code># systemctl enable --now kvmd-janus\n</code></pre> <p>Then reload the Web UI and then in the System menu you will see the video mode switch.</p> <p>Note</p> <p>If you don't see the switch, it means that either your browser does not support WebRTC, or the <code>kvmd-janus</code> service was not started.</p>"},{"location":"webrtc/#basics","title":"Basics","text":"<p>The MJPEG video stream uses the same HTTP connection that you use to get the web interface. This means that for remote access, you just need to forward ports 80 and 443 on your router.  Please review the Port Foward doc for proper usage.</p> <p>In contrast, WebRTC is a completely different way of transmitting video. It uses a P2P connection and UDP. This reduces network load, but makes it difficult to configure - the server needs to know your network configuration in order to use it correctly.</p> <p>To implement this, the PiKVM checks which of the network interfaces is used for the default gateway, and also tries to find out your external address using the Google STUN server. This is necessary when using Tailscale or so that you can connect to your PiKVM from the external Internet.</p> <p>If you don't like using Google (it was chosen as the default for reliability reasons) for this purpose, you can choose any other STUN server at your discretion, or set up your own.</p> <p>Edit <code>/etc/kvmd/override.yaml</code>:</p> <pre><code>janus:\nstun:\nhost: stun.stunprotocol.org\nport: 3478\n</code></pre> <p>... and restart <code>kvmd-janus</code> service using <code>systemctl restart kvmd-janus</code>.</p>"},{"location":"webrtc/#custom-janus-config","title":"Custom Janus config","text":"<p>Janus is a WebRTC gateway that is used to transmit the uStreamer video. KVMD-Janus is a wrapper around it, configuring and monitoring changes in the network configuration. This is suitable for most users. However, if your PiKVM is not connected to the Internet and/or you want to use a custom Janus configuration, then you should use the <code>kvmd-janus-static</code> service instead. You should first change the Janus configuration yourself. You can find it in <code>/etc/kvmd/janus/janus.jcfg</code>.</p> <pre><code># systemctl disable --now kvmd-janus\n...\n# systemctl enable --now kvmd-janus-static\n</code></pre>"},{"location":"webrtc/#troubleshooting","title":"Troubleshooting","text":"<p>In rare cases, WebRTC may not work. The most common reasons are:</p> <ul> <li> <p>Clearing the Cache</p> </li> <li> <p>Try other browsers - Try incognito or private window (this disableds all extensions)</p> </li> <li> <p>Tricky IPv6 configuration on the network. IPv6 support for WebRTC in PiKVM is still in its infancy, so if your network has IPv4, it will be easiest to disable IPv6 on PiKVM. To do this, switch the file system to write mode using <code>rw</code> command, add option <code>ipv6.disable_ipv6=1</code> to <code>/boot/cmdline.txt</code> and perform <code>reboot</code>. Also see here.</p> </li> <li> <p>A paranoid firewall when you try to connect to the PiKVM by forwarding port 443 to the Internet from the internal network. WebRTC is not enough of this, it uses UDP on ports 10000-20000 for a P2P connection. Make sure that the Firewall does not block them.</p> </li> <li> <p>If nothing helps, open the browser's JS console and look at the log, and contact our community via Discord. Developers and/or experienced users will definitely help you.</p> </li> <li> <p>Another option to try is if you have both wifi and eth connected, disable wifi <code>rfkill list wifi</code> then <code>rfkill block X</code> where is a number that shows in the output. Reason: Arch Linux will choose to route all outgoing packets out wifi by default.</p> </li> <li> <p>There are some linux distro's that require more work to be able to use H.264 (WEBRTC MODE), this may include any RedHat variant.</p> <ul> <li>For instance: On Fedora you can install the rpmfusion repos, then use the <code>chromium-freeworld</code> package instead of <code>chromium</code></li> </ul> </li> </ul>"},{"location":"wifi/","title":"Setting up Wi-Fi","text":""},{"location":"wifi/#setting-up-wi-fi","title":"Setting up Wi-Fi","text":"<p>The following describes how to setup a Wi-Fi connection on the default pikvm builds based on Arch Linux. The process might vary for other Linux distros. We recommend to do this while having a display and keyboard connected directly to the Raspberry Pi as you will loose network connectivity once you connect to a Wi-Fi. Alternatively you can connect to the PiKVM via SSH. The built-in Web Terminal (available through the browser) should also work.</p> <p>Warning</p> <p>Please review First Steps if you are setting up wifi for the zero2w. This guide also applies to Wi-Fi setup for v2+ devices if switching from Ethernet to Wi-Fi..</p> <p>Warning</p> <p>There is nothing more reliable than wired Ethernet, so it's better to use it. Wi-Fi with the steel case (on V3) results in poor performance. But who are we to stop you... :)</p> <p>[ADVANCED USERS ONLY] Moving Wi-Fi settings for OS older than 2021.10.19</p> <p>Starting from 2021.10.19, the old way to configure Wi-Fi using <code>netctl</code> is deprecated. Instead, it is proposed to use a more native path with <code>systemd-networkd</code>, which is already used to configure Ethernet. Follow the guide and then delete the old netctl profile:</p> <pre><code># rw\n# systemctl disable netctl-auto@wlan0.service\n# rm /etc/netctl/wlan0-*\n# ro\n</code></pre>"},{"location":"wifi/#step-by-step-advances-users-only-section","title":"Step by step - Advances users ONLY section","text":"<ol> <li> <p>Make filesystem writable using <code>rw</code> command.</p> </li> <li> <p>Create Wi-Fi settings file <code>/etc/systemd/network/wlan0.network</code> with following content:</p> <pre><code>[Match]\nName=wlan0\n\n[Network]\nDHCP=yes\nDNSSEC=no\n\n# Use same IP by forcing to use MAC address for clientID\n[DHCP]\nClientIdentifier=mac\n</code></pre> </li> <li> <p>Set network ESSID and password:</p> <pre><code># wpa_passphrase 'MyNetwork' 'P@assw0rd' &gt; /etc/wpa_supplicant/wpa_supplicant-wlan0.conf\n</code></pre> <p>Using Wi-Fi with hidden ESSID</p> <p>Add option <code>scan_ssid=1</code> to <code>/etc/wpa_supplicant/wpa_supplicant-wlan0.conf</code></p> <p>Using 5GHz Wi-Fi in the USA</p> <p>Add option <code>country=US</code> to <code>/etc/wpa_supplicant/wpa_supplicant-wlan0.conf</code></p> </li> <li> <p>Enable WPA-supplicant service:    </p><pre><code>systemctl enable wpa_supplicant@wlan0.service\n</code></pre> </li> <li> <p>Make filesystem read-only again using <code>ro</code> command</p> </li> </ol>"},{"location":"wifi/#useful-console-commands","title":"Useful console commands","text":"<ul> <li><code>iwconfig</code> - Manipulate the basic wireless parameters.</li> <li><code>iwlist</code> - Allow's you to initiate scanning and list frequencies, bit-rates, encryption keys, etc.</li> <li><code>iwspy</code> - Displays per node link quality.</li> <li><code>iwpriv</code> - Allow's you to manipulate the Wireless Extensions specific to a driver (private).</li> </ul> Some examples <pre><code># iw dev wlan0 scan | egrep \"signal:|SSID:\" | sed -e \"s/\\tsignal: //\" -e \"s/\\tSSID: //\" | awk '{ORS = (NR % 2 == 0)? \"\\n\" : \" \"; print}' | sort\n</code></pre> <pre><code># iwlist wlan0 scan | egrep \"Cell|ESSID|Signal|Rates\"\n</code></pre> <pre><code># iwlist wlan0 scan\n</code></pre> <pre><code># iw wlan0 info\n</code></pre>"},{"location":"wifi/#additional-resources","title":"Additional resources","text":"<ul> <li>Arch Linux Wiki for systemd-networkd</li> </ul>"},{"location":"wiring_examples/","title":"Wiring examples","text":""},{"location":"wiring_examples/#some-example-wiring-setups","title":"Some example wiring setups","text":""},{"location":"wiring_examples/#csi-geekworm-any-brand-will-be-the-same","title":"CSI (Geekworm) (Any brand will be the same)","text":"<p>List of items: (WARNING! Links may dissappear or no longer work, this just gives you an idea)</p> <ul> <li>USB-A male to USB-A male (For data)</li> <li>PortaPow USB Power Blocker</li> <li>USB C OTG Splitter</li> <li>Normal HDMI Cable</li> <li>DisplayPort TO HDMI pigtail (Cable) (Pic is displayed wrong)</li> <li>TARGET (Anything you want to control)</li> </ul>"},{"location":"wiring_examples/#another-csi-example-using-the-pcb-splitter","title":"Another CSI example using the PCB splitter","text":""},{"location":"wiring_examples/#usb","title":"USB","text":""},{"location":"wiring_examples/#direct-connect-to-target","title":"Direct connect to target","text":"<p>Explanation of pic - USB-C from PI to USB-A onto target which also powers the PI</p> <p>Use case:  - Trying to determine if the data cable is truly a data cable and not just a power cable - Testing to see if the splitter or cable is defective - Basic troubleshooting</p>"},{"location":"wiring_examples/#ezcoo-wiring-example","title":"EZCOO wiring example","text":""},{"location":"wol/","title":"Wake-on-LAN the server","text":""},{"location":"wol/#wake-on-lan","title":"Wake-on-LAN","text":""},{"location":"wol/#simplified-method-one-host","title":"Simplified method (one host)","text":"<p>To use Wake-on-LAN with your server you must define some options such as the server's MAC address and (optionally) IP address. Use <code>/etc/kvmd/override.yaml</code>. The format is:</p> <pre><code>kvmd:\nwol:\nmac: ff:ff:ff:ff:ff:ff\n</code></pre> <p>Replace <code>ff:ff:ff:ff:ff:ff</code> with the MAC of your server. By default, a packet is sent via a broadcast request to the entire IPv4 network (<code>255.255.255.255</code>, port <code>9</code>), but you can address it to a specific static address:</p> <pre><code>kvmd:\nwol:\nmac: ff:ff:ff:ff:ff:ff\nip: 192.168.0.100\n# port: 9  # By default\n</code></pre> <p>... then restart <code>kvmd</code> using <code>systemctl restart kvmd</code>. It will now show up in the system button in the upper right corner.</p>"},{"location":"wol/#gpio-method-multiple-hosts","title":"GPIO method (multiple hosts)","text":"<p>Follow the manual for building the GPIO menu and use the <code>wol</code> driver to build a menu with many buttons tied to different hosts.</p>"},{"location":"xh_hk4401/","title":"XH-HK4401 4-port HDMI USB KVM Switch","text":""},{"location":"xh_hk4401/#xh-hk4401-4-port-hdmi-usb-kvm-switch","title":"XH-HK4401 4-port HDMI USB KVM Switch","text":"<p>This KVM is sold under many names, and comes in two versions. The only way these two versions differ is that one has one of its USB ports replaced with a PS/2 port. The identifying feature is that they come with a small external control unit with 4 buttons. This controller is connected to the main KVM via a micro USB cable, however this is NOT as USB connection.</p> <p>Warning</p> <p>Audio was not tested, it is assumed to be non-functional</p>"},{"location":"xh_hk4401/#connections","title":"Connections","text":"<ol> <li> <p>Connect the USB-A cable from the Raspberry Pi OTG port to to any of the USB ports on the XH-HK4401 switch. All 3/4 USB ports work exactly the same, internally they are just connected to a USB HUB.</p> </li> <li> <p>Connect the HDMI out from the XH-HK4401 switch to the Raspberry Pi CSI-2 to HDMI input.</p> </li> <li> <p>Connect host USB and HDMI cables from the XH-HK4401 switch to the machines to be managed per the switch instructions.</p> </li> <li> <p>Finally see below for details about connecting to the control micro USB port. This it not a normal USB micro port.</p> </li> </ol> <p>Warning</p> <p>There is a limitation in the underlying PiKVM software related to plugging video cables from a host which is already powered and connected to a monitor to a Raspberry Pi HDMI-CSI bridge. These limitations apply equally when using the XH-HK4401 KVM switch. If video is not present in PiKVM, try keeping all host machines off and connecting them directly to the XH-HK4401 switch before powering the hosts on.</p>"},{"location":"xh_hk4401/#rs-232-control-cable","title":"RS-232 control cable","text":"<p>The control unit communicates to the KVM using the RS-232 protocol (at 5v) not USB, and one of the following solutions must be used.</p>"},{"location":"xh_hk4401/#inverting-usb-uart-adapter-ft-232-the-easy-way","title":"Inverting USB UART adapter (FT-232) - The easy way","text":"<p>Some USB UART adapters have the rare feature to invert the logic level of the RX/TX signals. For example the FTDI FT232 can be configured via the FTDI configuration GUI to do this. With such an adapter, the circuit above is not required. All you need is to connect it to a micro-USB connector.</p> <p>Warning</p> <p>These options will only work on UART adapters with genuine FTDI chips. There are a lot of cheap fakes on the market that either lack this option, or will prevent you from changing the settings. To avoid getting a fake ensure you always purchase from a reputable store and brand (Adafruit, Sparkfun, etc.), Amazon is not a reputable store.</p>"},{"location":"xh_hk4401/#linux-instructions","title":"Linux Instructions","text":"References I used to get my FTDIs working: <ul> <li>https://waterpigs.co.uk/articles/ftdi-configure-mac-linux/</li> <li>https://manpages.debian.org/testing/ftdi-eeprom/ftdi_eeprom.1.en.html</li> <li>https://manpages.ubuntu.com/manpages/bionic/man1/ftdi_eeprom.1.html</li> <li>http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.h</li> <li>http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.c</li> <li>http://developer.intra2net.com/git/?p=libftdi;a=tree;f=ftdi_eeprom</li> <li>http://developer.intra2net.com/git/?p=libftdi;a=blob;f=ftdi_eeprom/example.conf</li> <li>http://developer.intra2net.com/git/?p=libftdi;a=blob;f=ftdi_eeprom/main.c</li> </ul> <p>Warning</p> <p>Steps were performed on Debian-like installation (Pop!_OS 21.10)</p> <p>This workflow has worked for a self-described NON-genuine FTDI FT232RL chip. The other MAY be genuine, but it is also working.</p> <p>Neither of the following FTDI UART adapters are recommended. Purchasing both chips was an error (only 1 intended). However, having two (potentially non-genuine) FTDI UART adapters helped to create these instructions.</p> <ul> <li> <p>Possibly genuine, but working regardless, (DSD TECH) FTDI</p> </li> <li> <p>Not genuine (HiLetGo) FTDI</p> </li> </ul> <p>Warning</p> <p>The HiLetGo UART adapter comes with a USB MINI female connector and necessitates another adapter/cable for interfacing with the Pi.</p> <ol> <li> Get info from FTDI <ul> <li>Plug the FTDI into a USB port on your Linux device and run <code>lsusb</code> to verify that the device is found     <pre><code>lsusb\n</code></pre></li> <li>Ensure the device is recognized as FTDI     <pre><code>sudo lshw | grep -B 10 ftdi\n</code></pre></li> <li>Record hardware information (not sure if needed, but was saved to prevent overwriting critical data in the EEPROM)</li> </ul> </li> <li> Blacklist ftdi_sio kernel module <ul> <li>The kernel module ==ftdi_sio== is currently enabled (and how you saw the device in the previous step). We need to disable this module to read/write to the EEPROM.</li> <li>The following command creates a file to blacklist the ==ftdi_sio== module.     <pre><code>echo \"blacklist ftdi_sio\" | sudo tee /etc/modprobe.d/bl-ftdi.conf &gt; /dev/null\n</code></pre></li> </ul> </li> <li> Reboot machine <ul> <li>We need to reboot into an environment without ftdi_sio active.     <pre><code>shutdown -r 0\n</code></pre></li> </ul> </li> <li> Install ftdi_eeprom if not already installed <ul> <li>Install ==ftdi_eeprom== with the following command.     <pre><code>sudo apt install ftdi_eeprom\n</code></pre></li> </ul> </li> <li> Make a folder to work from and change it to our working directory <pre><code>mkdir ./ftdi_config\ncd ./ftdi_config\n</code></pre> </li> <li> Create a valid FTDI configuration file for ftdi_eeprom consumption <ul> <li>The below command (copy/paste all lines) will create a valid configuration file. Change parameters as required.     <pre><code>tee ./ftdi.conf &gt; /dev/null &lt;&lt;EOF\nfilename=eeprom.bin\nvendor_id=0x0403\nproduct_id=0x6001\nmanufacturer=\"FTDI\"\nproduct=\"FT232 Serial (UART)\"\nserial=\"SERIAL\"\nuse_serial=true\nmax_power=500\nself_powered=false\ninvert_txd=true\ninvert_rxd=true\ncha_type=\"UART\"\nEOF\n</code></pre></li> <li>This configuration is trimmed from the example due to size of the EEPROM on the FTDIs used.</li> <li>The example configuration at ==/usr/share/doc/ftdi-eeprom/example.conf== describes possible configuration options for the FTDI and is well-documented.</li> <li>The above configuration worked for the mentioned devices. The ==filename==, ==vendor_id==, ==product_id==, ==invert_txd==, and ==invert_rxd== variables are required. The others might not be, but seemed applicable.</li> <li>If you're using a different FTDI chip than used here, please update that in the above configuration. Ensure that vendor_id and product_id are what was obtained from the output of the initial <code>lsusb</code> command.</li> <li>==max_power==, ==serial==, and ==product== were updated to reflect the output of the initial <code>lshw</code>. These updates may not be required and were done to avoid overwriting anything important. ==cha_type== was updated to ==UART== where both of the devices were originally designated as FIFO.</li> </ul> </li> <li> Test the configuration and read the eeprom initially before flashing <ul> <li>Read the EEPROM with the following command     <pre><code>sudo ftdi_eeprom --read-eeprom ./ftdi.conf\n</code></pre></li> <li>If you get an error here, there's something wrong with your configuration. Check that the device is properly identified and try again.</li> </ul> </li> <li> Rename/preserve and review the contents of the binary read from the EEPROM <ul> <li>First, rename the output binary file so we don't overwrite it when we flash (flashing writes the flashed binary to the ==filename== path)     <pre><code>mv ./eeprom.bin ./original_eeprom.bin\n</code></pre></li> <li>Then, display the outputs of the binary     <pre><code>hexdump -C original_eeprom.bin\n</code></pre></li> <li>You can rename the binary in the configuration file by editing the ==filename== variable. If you can't be bothered to edit the file, rename it as detailed above.</li> </ul> </li> <li> Flash the configuration <ul> <li>Run the following command to flash the EEPROM of the FTDI     <pre><code>sudo ftdi_eeprom --flash-eeprom ./ftdi.conf\n</code></pre></li> <li>Optional: compare the flashed configuration to the initial configuration with the below command. If there is no output, the files are the same. You will likely need to re-flash.     <pre><code>diff &lt;(xxd original_eeprom.bin) &lt;(xxd eeprom.bin)\n</code></pre></li> <li>Alternatively, you can manually compare the files by running <code>hexdump -C original_eeprom.bin</code> and <code>hexdump -C eeprom.bin</code></li> </ul> </li> <li> Your FTDI should be flashed and working to control the KVM! <ul> <li>Plug it into one of the Pi's USB slots (if not already), and it's good to go.</li> <li>The KVM will sink power from the FTDI (Pi) if Vcc is connected. If Vcc is disconnected, ensure that grounds between the Pi and KVM are tied.</li> </ul> </li> <li> Clean up the ftdi blacklist to reenable the ftdi_sio module <ul> <li>Comment out the line but leave the file with the following command:     <pre><code>sudo sed -i 's/blacklist ftdi_sio/#blacklist ftdi_sio/g' /etc/modprobe.d/bl-ftdi.conf\n</code></pre></li> <li>If you'd need to read/flash FTDI EEPROM in the future, you can use the following command (followed by a reboot) to blacklist the ==ftdi_sio== module again.     <pre><code>sudo sed -i 's/#blacklist ftdi_sio/blacklist ftdi_sio/g' /etc/modprobe.d/bl-ftdi.conf\n</code></pre></li> <li>If you want to wash your hands of FTDI flashing, then delete the blacklist file with the following command:     <pre><code>sudo rm /etc/modprobe.d/bl-ftdi.conf\n</code></pre></li> </ul> </li> <li> Reboot the machine to reset to initial state (with ftdi_sio loaded) <ul> <li>==ftdi_sio== should reload as the driver, and the FTDI should be able to be seen with <code>lshw</code> / <code>dmesg</code> once again. If you tried to run either command while ==ftdi_sio== was blacklisted, you probably would have come up empty.</li> </ul> </li> </ol>"},{"location":"xh_hk4401/#windows-instructions","title":"Windows Instructions","text":"<p>In order to invert the RX/TX signals, you can use ft_prog and set the  following settings:</p> <p></p> <p>Once the UART is configured, please fully disconnect it and connect it back to the computer. Relaunch <code>ft_prog</code> and ensure the settings are still set. If they are not, you have a fake FTDI chip.</p>"},{"location":"xh_hk4401/#ftdi-terminal-configuration","title":"FTDI Terminal Configuration","text":"<p>Finally, you will need to connect it to the micro USB port (This it not a normal USB micro port.) like so:</p> Signal Colour FT232 Pin Vbus Red 5v (if you want to power the KVM from the Pi's USB) D- White RX D+ Green TX Gnd Black GND"},{"location":"xh_hk4401/#an-inverter-circuit-the-cheap-way","title":"An inverter circuit - The cheap way","text":"<p>For this you will need:</p> <ul> <li>1x 74HC14</li> <li>1x USB A socket, or sacrificial micro USB cable</li> <li>Optional 1x Diode - If you want to power the KVM from the Raspberry Pi</li> <li>1x 5-pin header</li> <li>5x Female - Female jumper cables</li> </ul> <p></p> <p>Note</p> <p>Please search online for USB pinouts to ensure you connect it properly.</p>"},{"location":"xh_hk4401/#adding-ui-elements-to-control-the-kvm-switch","title":"Adding UI elements to control the KVM switch","text":"<p>The UI can be updated to add buttons to switch between KVM inputs and indicators for which input is currently selected.  The instructions below will make these available in the PiKVM UI after clicking the \"GPIO\" menu button in the KVM view.</p> <ol> <li> <p>SSH into PiKVM</p> </li> <li> <p>Enable read-write mode on the sd card via <code>rw</code></p> </li> <li> <p>Edit the <code>/etc/kvmd/override.yaml</code> file and include the following. </p> </li> </ol> Method Device FT-232 <code>/dev/ttyUSB0</code> Inverter <code>/dev/ttyAMA0</code> <pre><code>kvmd:\ngpio:\ndrivers:\nhk:\ntype: xh_hk4401\ndevice: /dev/ttyUSB0\nscheme:\nch0_led:\ndriver: hk\npin: 0\nmode: input\nch1_led:\ndriver: hk\npin: 1\nmode: input\nch2_led:\ndriver: hk\npin: 2\nmode: input\nch3_led:\ndriver: hk\npin: 3\nmode: input\nch0_button:\ndriver: hk\npin: 0\nmode: output\nswitch: false\nch1_button:\ndriver: hk\npin: 1\nmode: output\nswitch: false\nch2_button:\ndriver: hk\npin: 2\nmode: output\nswitch: false\nch3_button:\ndriver: hk\npin: 3\nmode: output\nswitch: false\nview:\ntable:\n- [\"#Input 1\", ch0_led, ch0_button]\n- [\"#Input 2\", ch1_led, ch1_button]\n- [\"#Input 3\", ch2_led, ch2_button]\n- [\"#Input 4\", ch3_led, ch3_button]\n</code></pre> <ol> <li> <p>Return to read-only mode for the sd card via <code>ro</code></p> </li> <li> <p>Restart the kvmd service: <code>systemctl restart kvmd</code></p> </li> </ol>"},{"location":"xh_hk4401/#switching-between-hosts-in-the-ui","title":"Switching between hosts in the UI","text":"<p>To switch between hosts, enter the KVM UI and click the \"GPIO\" menu. You should see 4 inputs, one of which will have a green circle indicating it is currently selected. Click the other inputs to change the selected host.</p>"},{"location":"stl/atx/","title":"PiKVM v3 ATX mounting brackets for 3D printing","text":""},{"location":"stl/atx/#pikvm-v3-atx-mounting-brackets-for-3d-printing","title":"PiKVM v3 ATX mounting brackets for 3D printing","text":"<p>A good way to mount an ATX adapter in a computer case is to place it in a PCI slot. Here you can get drawings of PCI brackets for 3D printing.</p> Variant Description This is a standard bracket of common length, which will fit most personal computers The short bracket (low profile), for compact PCs or rack servers"},{"location":"stl/v3.2/","title":"3D printable case for PiKVM v3.2 HAT","text":""},{"location":"stl/v3.2/#3d-printable-case-for-pikvm-v32-hat","title":"3D printable case for PiKVM v3.2 HAT","text":"<p>When printing the case, you can choose the following options:</p> <ul> <li>The presence or absence of an OLED screen (used to display the IP address and other information).</li> <li>The presence or absence of holes for the AUM v3.3 (Advanced USB Module, most likely you don't have it).</li> </ul> <p>Also take a look at the PCI bracket for ATX adapter board.</p>"},{"location":"stl/v3.2/#buy-options","title":"Buy options","text":"<ul> <li>Small 5v fan strongly recommended to avoid overheating in the case.</li> <li>I2C OLED screen.</li> </ul>"},{"location":"stl/v3.2/#building","title":"Building","text":""},{"location":"stl/v3.2/#parts","title":"Parts","text":""},{"location":"stl/v3.2/#the-front-part","title":"The front part","text":"<p>Choose ONE of them.</p> Variant Description The front part of the case WITHOUT a hole for the OLED The front part of the case with a hole for installing the OLED"},{"location":"stl/v3.2/#the-back-part","title":"The back part","text":"<p>Choose ONE of them.</p> Variant Description The back part of the case WITHOUT AUM holes The back part of the case for installing the AUM"},{"location":"stl/v3.2/#spacers","title":"Spacers","text":"Type Description 6.2mm spacer, required TWO pieces 2mm spacer required TWO without AUM or ONE for AUM 1mm spacer required ONE for AUM only Low spacer required ONE"},{"location":"stl/v3.3/","title":"PiKVM v3.3 Plastic Case for 3D printing","text":""},{"location":"stl/v3.3/#pikvm-v33-plastic-case-for-3d-printing","title":"PiKVM v3.3 Plastic Case for 3D printing","text":"<p>When printing the case, you can choose the following options:</p> <ul> <li>The presence or absence of an OLED screen (used to display the IP address and other information).</li> </ul> <p>Also take a look at the PCI bracket for ATX adapter board and great unofficial case mod for Noctua fans</p>"},{"location":"stl/v3.3/#buy-options","title":"Buy options","text":"<ul> <li>Small 5v fan strongly recommended to avoid overheating in the case.</li> <li>I2C OLED screen.</li> </ul>"},{"location":"stl/v3.3/#parts","title":"Parts","text":""},{"location":"stl/v3.3/#the-front-part","title":"The front part","text":"<p>Choose ONE of them.</p> Variant Description The front part of the case WITHOUT a hole for the OLED The front part of the case with a hole for installing the OLED"},{"location":"stl/v3.3/#the-back-part","title":"The back part","text":"Variant Description The back part of the case"},{"location":"stl/v3.3/#spacers","title":"Spacers","text":"Type Description 6.2mm spacer, required TWO pieces 1mm spacer required TWO pieces Low spacer required ONE piece"},{"location":"stl/v3.3/#fasteners-screws","title":"Fasteners (screws)","text":"<p>The official PiKVM v3.3 hat came with eight M2.5 x 12mm screws for countersunk holes. You can use these with the case.</p>"},{"location":"stl/v3.3/#assembly","title":"Assembly","text":"<p>Note: the spacers slide over the (short) hexagonal standoffs included in the official v3.3 hat:</p> <p></p> <p>To assemble:</p> <ol> <li>Ensure the hexagonal standoffs are all attached to the top side of the v3.3 hat. Tip: if you need to remove the case in the future, you don't want these hexagonal standoffs spinning while you loosen the screws - be sure to tighten the standoffs more than you tighten the screws in step 17. You could even use some thread-locking fluid on the standoffs now.</li> <li>Ensure the bottom side of the Pi has no screws present</li> <li>Ensure you have eight M2.5 x 12mm screws free for later use.</li> <li>Slide the two short spacers over the two standoffs on the side of the hat which contains the ATX, keyboard/mouse emulation, and HDMI connector. See Figure 1.</li> </ol> Figure 1: 1mm spacer placement <ol> <li>Slide the two long spacers over the two standoffs on the opposite side of the HAT - near the LEDs, power input, and console-over-ethernet connector. See Figure 2.</li> </ol> Figure 2: Placement of 6.2mm spacers. <ol> <li>Attach the fan to the two headers labeled \"fan\" located next to the CSI ribbon cable and large capacitor.</li> <li>Slide the fan into the slot on the front part of the case. The fan should move fan from outside to inside the case. For the fan in Figure 3, this means mounting with the label facing the inside of the case and the black lead connected to the negative (-) terminal on the PCB. Ensure the fan leads don't bind as you slide the fan in. See Figure 3.</li> </ol> Figure 3: Fan placement <ol> <li>If you still have foam covering the GPI pins on the top side of the hat, now is a good time to remove them. Leaving this in place will restrict airflow. </li> <li>Flip the PiKVM over and set the low spacer bracket you printed on the bottomside of the Pi with the straight edge facing away from the SD card. See Figure 4.</li> </ol> Figure 4: Low spacer placement <ol> <li>While allowing the low spacer to continue resting on the Pi, gently slide the PiKVM into the front part of the case. Ensure the spacers clear the top of the case (likely facing away from you) and that the fan leads don't bind on anything. The low spacer should remain mostly in place thanks to the solder joints on the Pi.</li> <li>If successful, the low spacer should be fairly close to aligning with the holes in the case. Use a small screwdriver or tweezers to fix the alignment. You may need to insert the screwdriver into the case along the inner face to push the low spacer towards the holes. See video for reference.</li> <li>Insert 4 screws into the holes of the case and tighten enough so things don't fall out, but leave plenty of slack - you might need to push the electronics around slightly to align the holes in the next steps.</li> <li>Now is a good time to power on the PiKVM and ensure the fan spins. It should come on automatically unless you explicitly disabled it yourself.</li> <li>Slide the back part over the PiKVM and align with the front part you assembled in previous steps.</li> <li>Ensure the case seats properly around the connectors.</li> <li>Insert the remaining four screws into the case and tighten. If the holes don't line up, you can hold the case while pushing on some of the PiKVM connectors to shift the electronics inside the case.</li> <li>Tighten all screws.</li> <li>Tip your bartender.</li> </ol>"}]}